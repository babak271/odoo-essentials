# Chapter 7 Odoo 15 Development Record Set - Using Model Data

In the previous chapters, we took an overview of model creation and how to load data into the model. Now that we have a data model and its associated data, it's time to learn how to interact with it programmatically.

Business applications require business logic to calculate data, perform validation or automate operations. The Odoo framework API provides developers with tools to implement this business logic. Most of the time it is querying, transforming and writing data.

Odoo implements an ORM (Object Relational Mapping) layer on top of the underlying database. ORM provides an API (Application Programming Interface) for interacting with data. This API provides an execution environment and the creation of recordsets for objects to manipulate data stored in the database.

This section explains how to use the execution environment and record set to implement business processing through the required tools.

This chapter mainly explains the following contents:

- Use shell commands to interactively learn the ORM API
- Understand the execution environment and context
- Query data using recordsets and domains
- Access data in a recordset
- Write in the record
- Processing date and time
- Using Recordset
- Transactions and underlying SQL

After completing this chapter, you will be able to perform all of these operations using Odoo code and use these tools to implement your own business processes.

## Development Preparation

The code in this chapter is executed using the interactive shell command line, without the need to use the code in the previous chapters. For related code, see the **ch07/ch07_recorsets_code.py** file in the [GitHub repository](https://github.com/iTranslateX/odoo-essentials/tree/main/source-code/).

## Using the shell command line

Python comes with a command line interface, which is a great way to study its syntax. Odoo has a similar feature, which is the shell command line. You can execute commands interactively to understand its mechanism.

To use this command line, start Odoo with shell and the options you normally use to start Odoo:

Execute the following command in the command line and specify the database to use it:

```
(env15) $ odoo shell -c library.conf
```

At this point, you can see the normal service startup information in the terminal, but this is not the HTTP service that starts listening for requests, but a Python command window that waits for input.

This interactive command interface simulates the environment of running inside a **class** method as the **OdooBot** superuser. You can use the **self** variable, which is set to the **OdooBot** superuser record object.

For example, use the following command to view the **self** record set:

```
>>> self
res.users(1,)
>>> self._name
'res.users'
>>> self.name
'OdooBot'
>>> self.login
'__system__'
```

The following command prints the following:

- **self** variable contains **res.users** record set, which contains only one record with id 1
- View **self._name** to get the record set model name **res.users**
- The **name** field value of the record is **OdooBot**
- The **login** field value of the record is `__system__`

> **Changes in Odoo 12**
> The super user with ID 1 was changed from admin to internal user `__system__`. Now admin has ID 2 and is not a super user, but all permissions are automatically granted to it by default in standard applications. The main reason is to prevent users from using super user accounts to perform daily operations. The risk is that the user will skip permission rules and cause inconsistent data, such as cross-company associations. Super users are now only used to find problems or specific cross-company operations.

Just like Python, you can exit the command line by pressing Ctrl + D. This will terminate the service and return to the system shell command line.

Now we have learned how to start an Odoo shell session. This is very important for viewing the Odoo API functionality. Let's take a step further and learn about its execution environment.

## Execution Environment

Odoo recordsets operate in an ambient context, providing information about the context that triggered the operation, such as the database cursor used, the current Odoo user, etc.

Python code running in a model method can access the **self** recordset variable and access the local environment through **self.env**. The server shell environment also provides a **self** pointer, which is used similarly to methods.

In this section we learn about those attributes of the execution context and how to use them.

### Environment properties

We already know that **self** is a recordset. The recordset carries environmental information, like the user browsing the data and other context-related information (e.g., the language used and the time).

The current environment can be accessed using the env property of a recordset, as shown in the following example:

We can view the current environment through the following code:

```
>>> self.env
<odoo.api.Environment object at 0x7f9fb92e0fa0>
```

The execution environment in **self.env** has the following properties:

- **env.cr** is the database cursor in use
- **env.user** is the record of the current user
- **env.uid** is the session user id, same as **env.user.id**
- **env.context** is an immutable dictionary of session context data
- **env.company** is the current company
- **env.companies** User's Licensed Company

> **Changes in ODOO 13**
>
> **env.company** and **env.companies** were introduced in Odoo 13. In previous versions this information was read in the user record using **env.user.company_id** and **env.user.company_ids**.

The environment also provides access to a registry with all installed models, such as self.env['res.partner'] returns a pointer to the partner model. We can then use the search() or browse() methods to get a set of records:

```
>>> self.env["res.partner"].search([("display_name", "like", "Azure")])
res.partner(14, 26, 33, 27)
```

The res.partner model recordset returned in the above example contains four records with ids 14, 26, 33, and 27. The recordset is not sorted by id because the default sorting of the corresponding model is used. For the partner model, the default _order is display_name.

### Environment Context

The ambient context is a dictionary with session data that can be used in the client UI as well as in the server ORM and business logic.

In the client, it can carry information from one view to another, such as carrying the active record id in the previous view after clicking a link or button, and it can also provide default values ​​used in the next view.

On the server side, some recordset values ​​may depend on the locale settings provided by the context. A specific example is the **lang** key which affects the value of translatable fields.

The context can also provide signals to the server code. For example, when the active_test key is set to False, it will change the behavior of the search() method in the ORM, it will ignore the active mark in the record, and inactive (false deleted) records will also be returned.

The client's initial context looks like this:

```
>>> self.env.context
{'lang': 'en_US', 'tz': 'Europe/Brussels'}
```

Supplement: You can also use self.context_get() to obtain

The **lang** key is the user language, and **tz** is the time zone information. The content of the record may vary depending on the current context:

- Translatable fields have different values ​​depending on the active **lang** language
- Date fields will display different times depending on the active tz time zone

When you click a link or button in the previous view to open a view, the web client will automatically add some keys to the context to provide information about the history we are browsing:

- **active_model** is the name of the previous model
- **active_id** is the ID of the original record the user is in
- **active_ids** is the list of IDs selected by the user when browsing the list view

Wizard assistants often use these keys to find the records they want to operate on.

The context can be used to set configuration values ​​and enable default filters for target client views by using the following prefixes on the keys:

- Add **default_** prefix to the field name to set the default value for that field. For example **{'default_user_id': uid}** sets the current user as the default value.
- Prefixing a filter name with **default_search_** will automatically enable that filter. For example **{'default_search_filter_my_tasks': 1}** will activate a filter named **filter_my_books**.

These prefixes are commonly used in window actions and view ` <field context="{...}"> ` elements.

### Modify the record set execution environment and context

The recordset execution context can be modified to use the functionality described in the previous section or to add information to methods called on the recordset.

The environment and context can be modified using the methods described below. Each method returns a new recordset, as well as a copy of the original recordset with the environment modified:

- The **<recordset>.with_context(<dictionary>)** method replaces the context with the contents of the dictionary.
- The **<recordset>.with_context(key=value, ...)** method modifies the context attributes provided by its settings.
- The **<recordset>.sudo([flag=True])** method enables or disables superuser mode where permission rules can be skipped, and the context user remains unchanged.
- **<recordset>.with_user(<user>)** method changes the user to the provided user. You can pass a user record or ID number.
- **<recordset>.with_company(<company>)** method changes the company to the provided company. You can pass a company record or ID number.
- The **<recordset>.with_env(<env>)** method modifies all contexts of the recordset to the passed context.

> **Changes in ODOO 13**
>
> Odoo 13 introduced the with_user() and with_company() methods. In previous versions, switching users used the sudo([<user>]) method, which allowed you to switch to a superuser context from a specified user. In previous versions, switching companies used with_context(force=company=<id>) to set a context key that was selected in the relevant business logic.

In addition, the environment object also provides an env.ref() function, which takes an external identifier string and returns the corresponding record, as shown in the following example:

```
>>> self.env.ref('base.user_root')
res.users(1,)
```

If the external identifier does not exist, a ValueError exception is raised.

We have learned more about using the Python code execution environment on the Odoo server. The next step is to interact with data. The first thing to learn at this point is how to query data and create datasets, which will be discussed in the next section.

## Query data using recordsets and scopes

Odoo business logic needs to read data from the database and perform operations. This is achieved through recordsets, by querying the raw data and exposing it to Python objects that we can operate on.

In Odoo, Python is usually run in class methods, and **self** represents the recordset to be operated. Sometimes, we need to create a recordset for other models. In this case, we should get a pointer to the model and then query it to create a recordset.

The environment object is usually accessible through **self.env**, which holds references to all available models, which can be accessed through dictionary-like syntax. For example, to get a reference to the **partner** model, use **self.env['res.partner']** or **self.env.get('res.partner')**. This model pointer can then be used to create a recordset, which we will learn in the following section.

### Create a recordset

The search() method takes a domain expression and returns a set of records that match the condition. For example, [('name', 'like', 'Azure')] will return all records where the name field contains Azure.

If the model has a special field **active**, by default only records with **active=True** are included in the selection.

The following keyword arguments may also be used:

- The **order** keyword is a string used in the ORDER BY clause of a database query. It is usually a comma-separated list of field names. Each field name can be followed by the **DESC** keyword to indicate a reverse order.
- The **limit** keyword sets the maximum number of records to be retrieved.
- The **offset** keyword ignores the first n records and can be used with **limit** to query a specified range of records at once.

Sometimes we just need to know the number of records that meet a certain condition. In this case, we can use **search_count()** to effectively return the number of records instead of the record set.

The browse() method takes a list of IDs or a single ID and returns a recordset of those records. This is very convenient when we know the ID and want to fetch the record.

For example, to retrieve all partner records whose display name contains Lumber, use the following search() call:

```
>>> self.env['res.partner'].search([('display_name', 'like', 'Lumber')])
res.partner(15, 34)
```

When you know the list of IDs you want to query, use the browse() call as shown in the following example:

```
>>> self.env['res.partner'].browse([15, 34])
res.partner(15, 34)
```

In most cases these IDs are not known, so the **search()** method is more commonly used than **browse()**.

To better use **search()**, you need to have a good grasp of the syntax of scope filters. Therefore, we will focus on that in the next section.

### Scope Expressions

A domain is used to filter data records. It uses a special syntax that is parsed by the Odoo ORM to generate the **WHERE** expression in the database query. A scope expression is a list of conditions, each condition is a tuple of **('field name', 'operator', 'value')**. For example, the following is a valid scope expression with only one condition: **[('is_done', '=', False)]** .. A scope expression can also be empty of conditions. This will be converted to an empty list ( **[]** ), and the query result will return all records.

There are two types of execution scope contexts: client-side, such as window actions and client views, and server-side, such as Python code in permission record rules and methods. What can be used in the **field name** and **value** elements depends on the execution context.

Let's learn the detailed explanation of each scope condition: **field name**, **operator**, and **value**.

#### Field name elements in scope conditions

The first condition element is the name string of the desired filter field. When using scope expressions on the server side, the field name element can use dot notation to access the value of the associated model. For example, we can use **'publisher_id.name'** or even **'publisher_id.country_id.name'**.

Dot notation is not allowed in the client, only simple field names.

> **Tip**: When you need to use related records in the client, you cannot use dot notation. The solution is to add related records to the model through the **related=** attribute. In this way, you can directly access the model field to get the value.

#### Operator Elements in Scope Conditions

The second condition element is the operator applied to the filter condition. The operators that can be ignored are as follows:
Operator | Description |
| ---------------------------------- | --------------- -------------------------------------------------- -- |
| = | is equal to |
| != | is not equal to |
| < | Less than. In XML files, use < |
| <= | Less than or equal to. In XML files, use <= |
| > | Greater than. In XML files, use > |
| >= | Greater than or equal to. In XML files, use >= |
| like | contains the string value. Similar to using any match (_) for strings. It will match any single string, and % matches any group of characters. Same as =like and adding % around the search value. |
| ilike | Same as like, but ignores case. |
| !ERROR! undefined variable 'like' | Use the database's like operator when searching for values, and use _ and % to match any value in the value. Unlike ilike, which adds % on both sides of the search value. |
| !ERROR! undefined variable 'ilike' | Same as =like, but ignores case. |
| in | Checks if the field value is equal to any item in the value list. The value should be a list, but a single value is treated as a one-element list. |
| not in | The reverse operation of in. Checks whether the field value is not a child of the value list. |
| child_of | When the searched field has a hierarchical relationship defined, child_of checks whether the record is a child of the record identified by the value. |
| parent_of | When the searched field has a hierarchical relationship defined, parent_of checks whether the record is the parent of the record identified by the value.


These operators are applied to the field provided in the first element, using the value provided in the third element. For example, **('shipping_address_id', 'child_of', partner_id)** looks at the **partner_id** variable in the run context and reads its value. Query the **shipping_address_id** field in the database and select the record whose address is the child of the **partner_id** value.

#### Value elements in scope conditions

The third element is evaluated as a Python expression. You can use literal values ​​such as numbers, Booleans, strings, or lists, and you can use values ​​and identifiers in the evaluation context.

Record objects are not accepted. Instead, the ID of the corresponding record should be used. For example, instead of **[('user_id', '=', user)]**, use **[('user_id', '=', user** **.id** **)]**.

For recording rules, the following names are available in the run context:

- **user**: The record of the current user (equivalent to **self.env.user**). Use **user.id** to get the corresponding ID.
- **company_id**: ID of the active company record (equivalent to **self.env.company.id**).
- **company_ids**: List of allowed company IDs (equivalent to **self.env.companies.ids**).
- **time**: Python time module, providing date and time functions. Please see the [official manual](https://docs.python.org/3/library/time.html).

> Changes in ODOO 13
>
> **company_id** and **company_ids** context values ​​can be used in record rule calculations since Odoo 13. **user.company_id.id** used in previous versions is no longer recommended. For example, **['|', ('company_id', '=', False), ('company_id', 'child_of', [user.company_id.id])]** should now be written as **[('company_id', 'in', company_ids)]**.

#### Searching for multiple fields

When searching on multiple fields, the operator is applied to each field value, and if any field value matches the scope condition, the operated record will appear in the result.

The **=** and **in** operators are similar to the *contains* operator. Both check to see if any field value matches any value in the searched value list. Correspondingly, the **!=** and **not in** operators look for any value in the field value that does not match any value in the searched value list.

#### Combining domain expressions using multiple conditions

The domain expression is a list and contains multiple condition tuples. By default, these conditions are connected using the AND logical operator, which means it only returns records that meet all the conditions.

You can also use explicit logical operators - the '&' symbol for AND (the default), and the pipe operator '|' for OR. These two operators will act on the next two items, recursively. We'll look at these in more detail later.

For a more formal definition, domain expressions use prefix notation, also known as Polish notation: the operator is placed before the operand. AND and OR are binary operators, while NOT is a unary operator.

The exclamation mark '!' indicates the NOT operator, which can be used for the next operation, so it should be placed before the negated item to be executed. For example, **['!', ('is_done','=',True)]** will filter out all unfinished records.

Operators, such as **!** and **|**, can be nested, allowing the definition of complex **AND**/**OR**/**NOT** conditions. Let's explain this with an example.

In the server-side recording rules, we can see domain expressions similar to the following:

```
['|',
    ('message_follower_ids', 'in', [user.partner_id.id]),
    '|',
        ('user_id', '=', user.id),
        ('user_id', '=', False)
]
```

This field filters out all records like this:

- The current user is a follower, or
- the current user is the owner of the record (user_id), or
- Records no responsible user

The following figure is the abstract syntax tree representation of the domain expression in the example above:

![Odoo 12 domain expression abstract syntax tree](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fa5b607b631498fa3da638e1bad9963~tplv-k3u1fbpfcp-zoom-1.image)

Figure 7.1: Diagram depicting a combined scope expression

The first **|** (*OR*) operator acts on the result of the followers condition plus the next condition. The next condition is the union of two other conditions: the record's user ID is set to the current user or the user ID is not set.

#### Special scope conditions

It also supports some special scope conditions when you want something to be always true or always false.

The (1, "=", 1) condition is a true expression. You can use it with record rules to grant a higher user group permissions to all records. For example, you can override the original limited inherited record permission group User: Own Documents only with the User: All Documents group. You can see an example of this in the Odoo source code addons/sales_team/security/sales_team_security.xml.

Also supported is **(0, "=", 1)**, which represents an expression that is always false.

#### Grouping and aggregating data by fields

Sometimes we need to group records by data fields. In Odoo, we can use the **read_group()** method. The parameters of this method are as follows:

- The **domain** parameter is a list of scope expressions for filtering the retrieved records.
- **fields** is a list of field names in the format **field:aggr** for use with aggregate functions. Aggregate functions are those that **PostgreSQL** supports built-in, such as **sum**, **avg**, **min**, **max**, **count**, and **count_distinct**. For example: **["subtotal:sum"]** .
- The **groupby** parameter is a list of field names to group by.
- The **limit** parameter is an optional maximum number of groups to return.
- The **offset** parameter is the optional number of records to skip.
- The **orderby** argument is an optional *order by* clause string to use for the results (similar to what **search()** supports).
- **lazy** parameter, if set to **True**, only group by the first field, and add the remaining grouping fields to the `__context` result. The default value of this parameter is **True**, and all grouping fields are applied immediately when set to **False**.

Here is an example that groups partner records by country and counts the different statuses:

```
>>> self.env["res.partner"].read_group([("display_name", "like", "Azure")], fields=["state_id:count_distinct",], groupby=["country_id"] , lazy=False)
[{'__count': 4, 'state_id': 1, 'country_id': (233, <odoo.tools.func.lazy object at 0x7f38ac66fa80>), '__domain': ['&', ('country_id', ' =', 233), ('display_name', 'like', 'Azure')]}]
```

This will return a single grouped result list for country ID **233**. Run **self.env["res.country"].browse(233).name** and you can see that the country is the United States. The `__count` key shows that there are **4** partners with country ID **233**, and the **state_id** object shows the de-aggregated number of households: these users are in the same **1** country.

Now that we've learned how to create a recordset, we need to read data from it. In most cases this is a trivial operation, but for some field types there are some details we need to be aware of. The next section will help us understand this.

## Accessing data in a recordset

Once you have retrieved a dataset, you can view the data it contains. In the following sections we will explore how to access the data in a recordset.

We can get the field value of a single record, called a singleton. Related fields have special properties, and we can view related records by using dot notation. Finally, let's think about processing date and time records and converting formats.

### Accessing data in records

When a recordset has only one record, it is called a singleton. A singleton is still a recordset and can be used wherever a recordset is needed.

Unlike multi-element recordsets, singletons can access their fields using dot notation, such as:

```
>>> print(self.name)
OdooBot
```

In the next example we see the same behavior of the same **self** singleton and the recordset, which we can iterate over. It only has one record, so only one name is printed:

```
>>> for rec in self: print(rec.name)
...
OdooBot
```

Trying to access a field value in a recordset that has multiple records will result in an error, so this can be a problem when you are unsure whether you are operating on a singleton dataset.

> **Tip**: Although you cannot access records in a multi-recordset using dot notation, you can access them in batches by mapping values ​​to a recordset. This is done with **mapped()**. For example, **rset.mapped("name")** returns a list with **name** values.

For methods designed to operate only on singletons, use self.ensure_one() at the beginning. If self is not a singleton, an error will be thrown.

> **Tip**: **ensure_one()** function will also throw an error when the record is empty. To check whether **rset** has zero or one record, you can use **rset or rset.ensure_one()**.

Empty records are also singletons. This can be convenient because accessing the field value returns None instead of throwing an error. The same is true for related fields, and using dot notation to access related records will not throw an error.

Therefore, in actual use, there is no need to check whether it is an empty record set before accessing the field value. For example, instead of using **if record: print(record.name)**, we can write the simpler **print(record.name)** without any worries. We can also use the **or** condition to provide a default value for empty values: **print(record.name** **or "None"** **)**.

### Accessing related fields

We learned earlier that models can contain relational fields: many-to-one, one-to-many, and many-to-many. The values ​​of these field types are record sets.

For many-to-one fields, the value can be a singleton or an empty recordset. In both cases, the field value can be accessed directly. The following command is correct and safe:

```
>>> self.company_id
res.company(1,)
>>> self.company_id.name
'Your Company'
>>> self.company_id.currency_id
res.currency(1,)
>>> self.company_id.currency_id.name
'EUR'
```

To avoid trouble, empty records can be operated like singletons, and accessing their field values ​​will not return an error but return **False**. So we can use dot notation to traverse the fields without worrying about errors due to empty values, such as:

```
>>> self.company_id.parent_id
res.company()
>>> self.company_id.parent_id.name
False
```

### Accessing time and date values

In the recordset, date and datetime values ​​are presented as native Python objects, for example, when querying the last login date for the admin user:

```
>>> self.browse(2).login_date
datetime.datetime(2022, 5, 6, 3, 26, 21, 714562)
```

Because dates and datetimes are Python objects, they have access to all the functionality of those objects.

> **Changes in Odoo 12**
> date and datetime field values ​​are represented as Python objects, whereas in previous Odoo versions they were represented as text strings. Values ​​of these field types can still be represented using text as in previous Odoo versions.

Dates and times are stored in the database in native Coordinated Universal Time (UTC) format, regardless of time zones. The **datetime** values ​​seen in the recordset are also in UTC format, and when displayed to the user in the client, the **datetime** values ​​are converted to the user's time zone based on the current session's time zone setting, which is stored in the context's tz key, such as **{'tz': 'Europe/Brussels'}**. This conversion is the responsibility of the client, not the server.

For example, a user in Brussels (UTC+1) entering 11:00 AM will be stored in the database as 10:00 AM UTC, while a user in New York (UTC-4) will see it as 06:00 AM. Odoo server log message timestamps use UTC time, not the local server time.

The reverse conversion, from the session time zone to UTC, also needs to be done by the client when passing the user-entered datetime back to the server.

> **Tip**: Remember to use UTC for date and time data stored in the database and processed in server-side code. Even the timestamps of server-side log messages are expressed in UTC.

Now we have learned the details of accessing record data. However, our application will provide some automation for business processing, which inevitably requires writing data to the record set. We will learn more in the next section.

## Write in the record

There are two ways to write records: direct assignment using object form or using the **write()** method. **write()** method is the underlying method responsible for performing write operations and is also used directly when using external API or loading XML records. Object form assignment will be added to the ORM model later. It implements the active record mode and can be used in Python code logic.

> **Changes in ODOO 13**
>
> In Odoo 13, the ORM model introduces a new way to write to the database, called in-memory ORM. In previous Odoo versions, each write directly generated the corresponding database SQL command, which had a performance cost, especially when complex interdependencies caused repeated updates of the same record. Starting from Odoo 13, these operations are stored in a memory cache, and at the end of the transaction, the new flush() method is automatically called to perform the corresponding database operations at one time.

Next we will learn about these two methods and their differences.

### Using object assignment

Recordsets implement the **active record pattern**. This means that we can assign values ​​to them and then these values ​​are persisted in the database. This is a convenient way to manipulate data in a straightforward manner.

> **Changes in ODOO 13**
>
> Odoo 13 supports assigning values ​​to recordsets with more than one record. As of Odoo 12, only single records were supported for writing values, and to write multiple records you need to use the **write()** method.

Here is an example:

```
>>> root = self.env["res.users"].browse(1)
>>> print(root.name)
OdooBot
>>> root.name = "Superuser"
>>> print(root.name)
Superuser
```

When using active record mode, you can set the value of the associated field through a recordset assignment.

Date and time fields can be assigned values ​​either as native Python objects or as string representations in the Odoo default format:

```
>>> from datetime import date
>>> self.date = date(2020, 12, 1)
>>> self.date
datetime.date(2020, 12, 1)
>>> self.date = "2020-12-02"
>>> self.date
datetime.date(2020, 12, 2)
```

Binary fields should be assigned using base64-encoded values. For example, when reading raw binary data from a file, it must be converted using base64.b64encode() before assigning it to a field:

```
>>> import base64
>>> blackdot_binary = b"\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x08\x04\x00\x00\ x00\xb5\x1c\x0c\x02\x00\x00\x00\x0bIDATx\xdacd\xf8\x0f\x00\x01\x05\x01\x01'\x18\xe3f\x00\x00\x00\x00IEND\xaeB'\ x82"
>>> self.image_1920 = base64.b64encode(blackdot_binary).decode("utf-8")
```

When assigning a value to a many-to-one field, the value assigned must be a single record (i.e. a singleton recordset).

You can also use recordset assignment for multiple fields to replace the associated record list with a new recordset. Recordsets of any size are allowed here.

When setting a null value for an associated field, you can set it to **None** or **False**.

```
>>> self.child_ids = None
>>> self.child_ids
res.partner()
```

Appending or removing records from an assignment list is done using record operations.

For example, suppose the company record also has an associated partner record that stores address details. Suppose we want to add the current user as a child contact of the company. This can be achieved with the following command:

```
 >>> mycompany_partner = self.company_id.partner_id
 >>> myaddress = self.partner_id
 >>> mycompany_partner.child_ids = mycompany_partner.child_ids | myaddress
```

The pipeline operator ( **|** ) is used here to concatenate records to obtain a larger set of records.

The same effect can be achieved using the more concise append assignment operator ( **|=** ):

```
>>> mycompany_partner.child_ids |= myaddress
```

For more information about record operation operators, see the **Constructing Recordsets** section of this chapter.

### Write via write() method

We can also use the write() method to update data in a record at the same time. It receives a dictionary with field names and values ​​to be assigned. This can be convenient in many scenarios, for example, when you prepare the dictionary first and assign values ​​later. It is also useful for scenarios where direct assignment is not possible in older versions of Odoo (up to Odoo 12).

The write() method takes a dictionary of fields and their values ​​and uses them to update the recordset:

```
>>> Partner = self.env['res.partner']
>>> recs = Partner.search( [('name', 'ilike', 'Azure')] )
>>> recs.write({'comment': 'Hello!'})
True
```

Date and time fields can be assigned values ​​using the corresponding Python objects or string literals, just like object assignments.

Starting from Odoo 13, **write()** can use recordsets to set values ​​for one-to-one and one-to-many relationship fields, just like object-based assignments.

> **Changes in ODOO 13**
>
> The **write()** method can use a recordset to assign values ​​to related fields. As of Odoo 12, many-to-one fields are set using ID values, while multi-fields are set using a special syntax, such as **(4, <id>, _)** to add a record and **(6, 0, [<ids>])** to set a complete list of records. This syntax is discussed in [Chapter 5 Odoo 15 Development: Importing, Exporting, and Module Data](5.md).

For example, suppose there are two Partner records: **address1** and **address2**, and we want to set them to the **self.child_ids** field.

Use the **write()** method, the command is as follows:

```
>>> self.write({ 'child_ids': address1 | address2})
```

Another way (needed to use in Odoo versions prior to 13) is as follows:

```
self.write({ 'child_ids': [(6, 0, [address1.id, address2.id])]})
```

The **write()** method is used to write data to an existing record. But we also need to create and delete records, which will be discussed in the next section.

### Creating and Deleting Records

Model methods create() and unlink() can be used to create records and delete existing records respectively.

The create() method accepts a dictionary of fields and values ​​to create a record, with the same syntax as write(). Yes, default values ​​will be automatically applied, as shown in the following example:

```
>>> Partner = self.env['res.partner']
>>> new = Partner.create({'name': 'ACME', 'is_company': True})
>>> print(new)
res.partner(56,)
```

The unlink() method deletes the records in the recordset, as shown in the following example:

```
>>> rec = Partner.search([('name', '=', 'ACME')])
>>> rec.unlink()
2022-06-05 01:53:09,906 43 INFO odoo-dev odoo.models.unlink: User #1 deleted mail.message records with IDs: [22]
2022-06-05 01:53:09,952 43 INFO odoo-dev odoo.models.unlink: User #1 deleted res.partner records with IDs: [56]
2022-06-05 01:53:09,961 43 INFO odoo-dev odoo.models.unlink: User #1 deleted mail.followers records with IDs: [6]
True
```

The unlink() method returns True. When deleting, a log message is triggered to inform us of the cascade deletion of related records, such as Chatter messages and followers.

Another way to create a record is to copy an existing record. The model method copy() can be used for this. It accepts an optional dictionary parameter containing the values ​​to overwrite when creating the new record.

For example, the example of creating a new user through the **demo** user is as follows:

```
>>> demo = self.env.ref("base.user_demo")
>>> new = demo.copy({"name": "John", "login": "john@example.com"})
```

Fields with the **copy=False** attribute will not be automatically copied. Fields with this attribute are disabled by default and therefore cannot be copied.

In the previous section, we learned how to access data in a recordset and write to a recordset. But we need to pay attention to certain field types. In the next section, we discuss specific techniques for manipulating dates and times.

## Handling dates and times

In the Accessing Data in Recordsets section, we learned how to read date and time values ​​from recordsets. It is common to perform date calculations and convert between native formats and string representations. Let's learn about such operations here.

Odoo provides some useful functions for creating new date and time objects.

The odoo.fields.Date object provides these helper functions:

- fields.Date.today() returns the current date as a string in the format required by the server, using UTC as a reference. This is sufficient to calculate the default value. This can be used directly in the date field definition via **default=fields.Date.today**.
- **fields.Date.context_today(record, timestamp=None)** returns a string with the current date in the session context. The time zone is taken from the record context. The optional **timestamp** parameter is a **datetime** object, if passed in then the current time is not used, the passed in value is used.

The **odoo.fields.Datetime** object provides the following date and time creation functions:

- **fields.Datetime.now()** function returns the current date and time in the format required by the server, using UTC as reference. This is sufficient to calculate the default value. It can be used directly in the datetime field definition via **default=fields.Datetime.now**.
- **fields.Datetime.context_timestamp(record, timestamp)** The function converts a raw datetime value (without time zone) to a datetime with a specific time zone. The time zone is extracted from the record context, hence the aforementioned function name.

### Addition and subtraction of time

Date objects can be compared and subtracted to get the time difference between two dates. The time difference is a **timedelta** object. **timedelta** can be used to add and subtract date and datetime objects through date operations.

These objects are provided by the Python standard library **datetime** module. Here are some examples of basic operations using it:

```
>>> from datetime import date
>>> date.today()
datetime.date(2022, 6, 5)
>>> from datetime import timedelta
>>> date(2022, 6, 5) + timedelta(days=7)
datetime.date(2022, 6, 12)
```

For a complete reference to the date, datetime, and timedelta data types, see the [Python official documentation](https://docs.python.org/3/library/datetime.html).

**timedelta** objects support weeks, days, hours, seconds, etc. But not years or months.

To perform date arithmetic on months or years, you should use a relativedelta object. Here is an example of adding a year and a month:

```
>>> from dateutil.relativedelta import relativedelta
>>> date(2022, 6, 5) + relativedelta(years=1, months=1)
datetime.date(2023, 7, 5)
```

The relativedelta object provides advanced date operations, including calculations for leap years and Easter. The official documentation is at https://dateutil.readthedocs.io.

Odoo also provides some additional functions in the **odoo.tools.date_utils** module:

- **start_of(value, granularity)** is the start time of a specific scale time interval, these scales are year, quarter, month, week, day or hour.
- **end_of(value, granularity)** is the end time of a specific tick time interval.
- **add(value, **kwargs)** adds a time interval to the specified value. The ****kwargs** parameter is a **relativedelta** object defining the time interval. These parameters can be years, months, weeks, days, hours, minutes, etc.
- **subtract(value, **kwargs)** Subtract a time interval from the specified value

These utility functions are also available for **odoo.fields.Date** and **odoo.fields.Datetime** objects.

The following are examples of using the above functions:

```
>>> from odoo.tools import date_utils
>>> from datetime import datetime
>>> now = datetime(2022, 6, 5, 0, 0, 0)
>>> date_utils.start_of(now, 'week')
datetime.datetime(2022, 5, 30, 0, 0)
>>> date_utils.end_of(now, 'week')
datetime.datetime(2022, 6, 5, 23, 59, 59, 999999)
>>> today = date(2022, 6, 5)
>>> date_utils.add(today, months=2)
datetime.date(2022, 8, 5)
>>> date_utils.subtract(today, months=2)
datetime.date(2022, 4, 5)
```

### Convert date and time objects to text form

Sometimes you need to convert a Python date object to textual form. You might need this when preparing user messages or formatting data to send to another system.

The Odoo field object provides some helper functions for converting native Python objects to strings:

- The **fields.Date.to_string(value)** function converts the **date** object into the string format required by the Odoo server.
- The **fields.Datetime.to_string(value)** function converts the **datetime** object into the string format required by the Odoo server.

They use the predefined default values ​​of the Odoo server, which are defined as constants as follows:

- **odoo.tools.DEFAULT_SERVER_DATE_FORMAT**
- **odoo.tools.DEFAULT_SERVER_DATETIME_FORMAT**

They map to **%Y-%m-%d** and **%Y-%m-%d %H:%M:%S** respectively.

The **date.strftime** and **datetime.strftime** functions accept a format string argument that is used to convert the other to text.

For example, the following example:

```
>>> date(2022, 6, 5).strftime("%d/%m/%Y")
'05/06/2022'
```

For details on the formatting codes, see the [official documentation](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior).

### Convert textual representation of date and time

Sometimes a date in string format needs to be converted to a Python **date** or **datetime** object. This was often needed in Odoo 11 and before, where dates were read as text. There are tools to help convert between text and native date types.

To help convert between formats, the **fields.Date** and **fields.Datetime** objects provide these methods:

- The **fields.Date.to_date** method converts a string to a **date** object.
- **fields.Datetime.to_datetime(value)** method converts a string to a **datetime** object.

An example of using to_datetime is as follows:

```
>>> from odoo import fields
>>> fields.Datetime.to_datetime("2020-11-21 23:11:55")
datetime.datetime(2020, 11, 21, 23, 11, 55)
```

In the above example, Odoo's built-in date format is used to parse the string and then converted into a Python **datetime** object.

For other date and time formats, use the strptime method of the date and datetime objects:

```
>>> from datetime import datetime
>>> datetime.strptime("03/11/2020", "%d/%m/%Y")
datetime.datetime(2020, 11, 3, 0, 0)
```

In most cases, the time in text form is not the UTC time required by the Odoo server. It needs to be converted to UTC time before storing it in the Odoo database.

For example, the user time **2020-12-01 00:30:00** in the Brussels time zone (UTC +1:00 hours) should be stored as the UTC time **2020-11-30 23:30:00** in the database. The code is as follows:

```
 >>> from datetime import datetime
 >>> import pytz
 >>> naive_date = datetime(2020, 12, 1, 0, 30, 0)
 >>> client_tz = self.env.context["tz"]
 >>> client_date = pytz.timezone(client_tz).localize(naive_date)
 >>> utc_date = client_date.astimezone(pytz.utc)
 >>> print(utc_date)
 2020-11-30 23:30:00+00:00
```

This code gets the user time zone from the context and then uses it to convert a native date to a time-dependent date. The last step is to convert the client time zone date to a UTC date using astimezone(pytz.utc) .

So far we have learned some techniques for handling dates and times in Odoo. There are also some specific techniques for handling values ​​stored in recordsets and relational fields, which we will discuss in the next section.

## Using Recordsets

A recordset is a collection of records, and is often used in Python's business logic. Several operations can be performed on recordsets, such as mapping and filtering. New recordsets can be written by adding or removing records. Other operations include checking the contents of a recordset to see if it contains a specific record.

> **Changes in ODOO 10**
>
> Starting from Odoo 10, recordset operations preserve the order. In previous Odoo versions, recordset operations did not necessarily preserve the order, but addition and slicing did.

### Recordset Operation

Recordsets contain functions that can perform operations on them, such as sorting or filtering records.

Supported functions and properties are:

- **recordset.ids** property returns a list of IDs of the recordset elements
- **recordset.ensure_one()** function checks whether it is a single record (singleton); if not, it throws a **ValueError** exception
- The **recordset.filtered(<function or str>** function returns a filtered recordset. The function is a test function for filtering records. The parameter can also be a dot-separated sequence of fields containing the desired operation. Records where the operation is true will be selected.
- **recordset.mapped(<function or str>)** The function returns a list of values, one for each record. The argument can also be a dot-separated sequence of fields containing the desired operation to be applied to the returned fields. It is safe to use multiple fields in the sequence of fields.
- **recordset.sorted(<function ot str>)** Returns a sorted recordset. The function returns a value for each record. The argument can also be a string with the name of the field to sort. Note that dot notation for sequences of fields is not allowed. There is an optional parameter **reverse=True**.

Examples of using these functions are as follows:

```
>>> rs0 = self.env["res.partner"].search([("display_name", "like", "Azure")])
>>> len(rs0) # several records
4
>>> rs0.filtered(lambda r: r.name.startswith("Nicole"))
res.partner(27,)
>>> rs0.filtered("is_company")
res.partner(14,)
>>> rs0.mapped("name")
['Azure Interior', 'Brandon Freeman', 'Colleen Diaz', 'Nicole Ford']
>>> rs0.sorted("name", reverse=True).mapped("name")
['Nicole Ford', 'Colleen Diaz', 'Brandon Freeman', 'Azure Interior']
>>> rs0.mapped(lambda r: (r.id, r.name))
[(14, 'Azure Interior'), (26, 'Brandon Freeman'), (33, 'Colleen Diaz'), (27, 'Nicole Ford')]
```

### Constructing a recordset

Recordsets are immutable, meaning their values ​​cannot be modified directly. But we can construct a new recordset based on an existing recordset. Slice notation is commonly used in Python lists and can be used on recordsets to extract a subset of records. Here are some examples:

- **rs[0]** and **rs[-1]** return the first and last element respectively
- **rs[1:]** returns a copy of the recordset except the first element
- **rs[:1]** returns the first element of the recordset

> **Tip**: A safe way to get the first element from a recordset is **rs[:1]** rather than **rs[0]**. The latter will fail if **rs** is empty, while the former will just return an empty recordset. Another option is the **first()** method in the **odoo.fields** module: **fields.first(rs)**.

Recordsets also support the following set operations:

- **rs1 | rs2** is a set union operation, which generates a record set containing all the elements of the two record sets. This is a set-like operation and does not produce duplicate elements.
- For example, **self.env.user | self.env.user** returns a single record, such as **res.users(1,)**.
- **rs1 & rs2** is a set intersection operation, which generates a data set consisting only of elements that appear in both record sets.
- **rs1 - rs2** is a set difference operation, which will generate a data set consisting of elements that are present in **rs1** but not in **rs2**.

We can directly use the following shorter notation to assign the operation:

- **self.author_ids |= author1**: If **author1** does not exist in the record set, **author1** will be added to the record set.
- The **self.author_ids &= author1** operation only retains records that also exist in the **author1** record set.
- **self.author_ids -= author1**: If **author1** exists in the record set, delete it

### Record set append

Sometimes we want to traverse some logic and accumulate the result records of each loop. The way to append in ORM is to use an empty record set first, and then continue to add records. To get an empty record set, create a model pointer. For example, the following command:

```
>>> Partner = self.env['res.partner']
>>> recs = self.env['res.partner']
>>> for i in range(3):
... rec = Partner.create({"name": "Partner %s" % i})
... recs |= rec
...
>>> print(recs)res.partner(58, 59, 60)
```

The above code loops three times, creating a new partner record each time and appending it to the **recs** recordset. Because it is a recordset, the **recs** variable can be used in any place where a recordset can be used, such as assigning values ​​to multiple fields.

However, appending a recordset is not time-efficient and should be avoided in a loop. The reason is that Odoo's recordset is an immutable object, and any operation on the recordset requires a copy to obtain the changed version. When appending a record to a recordset, the original recordset is not changed. Instead, a copy of the appended record is made. Copying operations are time-consuming, and the larger the recordset, the longer it takes.

Therefore, it is necessary to consider alternatives. Using the previous example, we can collect the dictionary of records in a Python list and then create all of them with a single create() call. This is possible because the create() method accepts a list of dictionaries.

So we can turn the loop into this:

```
values ​​= []
for i in range(3):
    value = {"name": "Partner %s" % i}
    values.append(value)
recs = self.env["res.partner"].create(values)
```

But this solution is not suitable for all scenarios. Another option is to use Python lists to collect records. Python lists are mutable objects, and the operation of appending elements is efficient. Because Python lists are not record sets, this solution cannot be used in record set scenarios, such as assigning values ​​to multiple fields.

Here is an example of grouping records in a Python list:

```
Partner = self.env["res.partner"]
recs = []
for i in range(3):
    rec = Partner.create({"name": "Partner %s" % i})
    recs.append(new_rec)
```

The examples above describe some techniques for building a recordset from individual elements using loops. However, some scenarios do not necessarily require loops, and operations such as **mapped()** and **filtered()** can be implemented more efficiently.

### Recordset Comparison

In some scenarios, we need to compare the contents of recordsets to decide whether to perform further operations. Recordsets support conventional comparison operations.

To check whether the record **<rec>** is an element in the **<my_recordset>** recordset, you can use the following code:

- **<rec> in <my_recordset>**
- **<rec> not in <my_recordset>**

You can also compare records to see if one recordset contains another. To compare two recordsets **set1** and **set2**:

 

- **set1 <= set2** and **set1 < set2** return **True** if all elements in **set1** are also in **set2**. **<** operator returns **False** if the elements in two recordsets are the same.
- **set1 >= set2** and **set1 > set2** return **True** if all elements in **set2** are also in **set1**. **>** operator returns **False** if the elements in two recordsets are the same.

## Database transactions and underlying SQL

ORM methods called by the client run in transactions. Transactions ensure data correctness in the event of concurrent writes or errors. In a transaction, data records are locked to protect them from other concurrent transactions and to ensure that there are no unplanned changes. In the event of an error, all changes made by the transaction are rolled back to the original state.

PostgreSQL provides support for transactions. When an ORM method is called through the client, a new transaction is initialized. If an error occurs during the execution of the method, all changes are undone. If the method is executed and no error is reported, the changes are committed, making the changes valid and visible to other transactions.

This is handled automatically and you don't usually need to worry about it, but in some advanced use cases it may be useful to have some control over the current transaction.

> **Changes in ODOO 13**
>
> Since Odoo 13, database writes are not done when the method is run. Instead, they are aggregated in a memory cache, and the actual database write is delayed until the end of the method execution, which is performed by the automatically triggered **flush()** call.

### Controlling database transactions

In some scenarios, it is beneficial to control transactions, which can be achieved using the database cursor **self.env.cr**. For example, it is necessary to iterate through the records and perform operations on each record, hoping to skip those with operation errors and not affect other records.

To this end, the object provides the following methods:

- **self.env.cr.commit()** Commit the write operation of the transaction buffer to make it effective in the database.
- **self.env.cr.rollback()** Cancel the write operation after the last commit. If it has not been committed yet, roll back all operations.

> **Tip:** Odoo's shell session simulates the method execution context. Database writes are not performed until **self.env.cr.commit()** is called.

### Execute native SQL

The values ​​parameter can be a tuple or a dict. When using a tuple, the parameters are replaced with **%s**, and when using a dict, they are replaced with **%(<name>)s**. Here are examples of both approaches:

Through the cursor's **execute()** method, we can run SQL statements directly in the database. It receives a SQL statement string to be run, and a second optional parameter: a SQL parameter value.

This parameter value can be a tuple or a list. When using a tuple, the parameter is replaced with **%s**, and when using a dictionary, it is replaced with **%(<name>)s**. Examples of these two methods are as follows:

```
>>> self.env.cr.execute("SELECT id, login FROM res_users WHERE login=%s OR id=%s", ("demo", 1))
>>> self.env.cr.execute("SELECT id, login FROM res_users WHERE login=%(login)s OR id=%(id)s", {"login": "demo", "id": 1 })
```

The above SQL command requires replacing parameters and preparing the result cursor to be fetched. For more details, please refer to the official documentation of **psycopg2**.

> **Note:**
> In cr.execute() we should not directly write SQL queries with concatenated parameters. It is well known that doing so will bring security risks of SQL injection attacks. Keep using **%s** placeholders and pass values ​​through the second parameter.

Use the **fetchall()** function to get the results and return a tuple of data rows:

```
>>> self.env.cr.fetchall()
[(1, '__system__'), (6, 'demo')]
```

You can also use the **dictfetchall()** function to get records as a dictionary:

```
>>> self.env.cr.dictfetchall()
[{'id': 1, 'login': '__system__'}, {'id': 6, 'login': 'demo'}]
```

> **Tip**: **self.env.cr** database cursor object is Odoo's wrapper around the PostgreSQL library **psycopg2**. That is to say, **psycopg2**'s [official documentation](https://www.psycopg.org/docs/cursor.html) will help us fully understand how to use this object.

You can also use Data Manipulation Language (DML) to run commands such as **UPDATE** and **INSERT**. The Odoo environment relies on data caching, which can cause inconsistencies between the executed DML and the actual data in the database. For this reason, after using native DML, you should clear the cache using **self.env.cache.invalidate(fnames=None, ids=None)**.

**fnames** is a list of field names to clear and refresh. If not provided, all fields will be cleared.

**ids** is a list of record IDs to clear and refresh. If not provided, all fields will be cleared.

> **Note:**
> Executing SQL statements directly in the database may skip ORM validation and dependencies, resulting in data inconsistency. Please do this only when you are sure.

## Summarize

In this chapter, we learned how to manipulate model data to perform CRUD operations: create, read, update, and delete data, as well as all the skills needed to process and operate the database. This is the cornerstone of implementing our business logic and automation code.

For testing of the ORM API, we used the Odoo interactive shell command line. We ran the commands through the self.env environment, which is similar to the environment in model methods and is therefore useful for exploring Odoo API capabilities.

This environment allows us to view data in any Odoo model and generate recordsets. We learned different ways to create recordsets and how to read the provided data, including some special data types such as dates, binary values, and relational fields.

Another basic capability of Odoo is writing back data. In this chapter, we learned how to create new records, write to existing records, and delete records.

We also learned about working with date and time values, using Python's built-in tools as well as some helper functions included with the Odoo framework.

You can manipulate record sets to add elements, filter records, reorder or append values, and compare record sets or view the inclusion relationship of specific records. These operations may be required when implementing business logic, and their basic techniques are explained in this article.

Finally, we may need to skip the use of ORM models and use low-level SQL operations to directly access the database or control transactions more precisely. This can be used to deal with scenarios where the ORM model is not ideal for the task.

Now that we have learned so much about the tools, we can move on to the next chapter, where we will learn about the business logic layer of the model and implement model methods that automatically operate using the ORM API.

## Expand your knowledge

Odoo official documentation about recordsets.