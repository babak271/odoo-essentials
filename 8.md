# Chapter 8 Business Logic of Odoo 15 Development - Business Process Support

In the previous article, we learned how to use the model layer to build application data structures, and then use the ORM API and recordsets to view and manipulate this data.

In this chapter, we will put together what we have learned so far to implement some common logic patterns in applications. We will learn how to trigger business logic together and some common patterns that support these methods. We will also learn some important development skills, such as logging, debugging, and testing.

The main contents of this chapter are

- Learning Project-Book Lending Module
- How to trigger business logic
- Understand recordset ORM method decorators
- Explore some data model patterns
- Use ORM built-in methods
- Add onchange UI logic
- Message and event functions
- Creation Wizard
- throw an exception
- Writing unit tests
- Using log messages
- Learn some development tools

After completing this chapter, readers can freely design and implement business logic automation and understand how to test and debug code.

## Development Preparation

In this chapter, we will create a **library_checkout** plugin module. It depends on the **library_app** and **library_member** plugin modules created in the previous chapters.

The code of these plugin modules can be found in the **ch08** directory of the [GitHub repository](https://github.com/iTranslateX/odoo-essentials/tree/main/source-code/).

These plug-in modules must be placed in the Odoo plug-in path so that they can be installed and used.

## Learning Project – Book Lending Module

The main data structure of the library application is ready. Now we need to add transactions to the system. Let library members borrow books. That is, we need to track whether the book is available for borrowing and whether it has been returned.

Each book loan has a life cycle, from the time the book is checked in to the time the book is returned. This can be represented as a simple workflow through the Kanban view, where each stage can be displayed as a column, and work items and loan requests flow from the left column to the right column until they are completed.

In this chapter, we focus on learning the data model and business logic that implement this functionality.

The details of the user interface part will be discussed in [Chapter 10 Odoo 15 Development Background View - Design User Interface] (10.md), and the Kanban view will be discussed in [Chapter 11 Odoo 15 Development Kanban View and User-side QWeb] (11.md). Let's quickly go over the data model.

### Preparing the data model

First, we will define the data model required for the book borrowing function.

The book borrowing model should contain the following fields:

- Members who borrow books (required)
- Borrowing request date (default is today)
- The user responsible for borrowing (the default is the current user)
- A borrowing route, which contains one or more books requested

To support the borrowing lifecycle, you need to add the following:

- The stage of the request: Selected, Available for borrowing, Loaned, Returned, or Cancelled
- Due Date, the date the book should be returned
- Return, the date the book is returned

We first create a new library_checkout module and implement the initial version of the book borrowing model. Compared with the previous chapters, no new knowledge is introduced here, which is used to provide a foundation for building new features later in this chapter.

### Create a module

As in the previous section, you need to create the library_checkout module. Follow the steps below:

1. Create a **library_checkout** directory in the same path as other book plug-in modules. Subsequent files are added to this directory.

1. Add the following content to the `__manifest__.py` file:


    ```
    {
        'name': 'Library Book Borrowing',
        'description': 'Members can borrow books from the library.',
        'author': 'Alan Hou',
        'depends': ['library_member'],
        'data':[
            'security/ir.model.access.csv',
            'views/library_menu.xml',
            'views/checkout_view.xml',
        ],
    }
    ```

1. Create a `__init__.py` file in the module directory and add the following code:


    ```
    from . import models
    ```

1. Create a `models/__init__.py` file and add:


    ```
    from .import library_checkout
    ```

1. Add a model definition file `models/library_checkout.py` and add the following code:


    ```
    from odoo import fields, models
    class Checkout(models.Model):
        _name = "library.checkout"
        _description = "Checkout Request"
        member_id = fields.Many2one(
            "library.member",
            required=True,
        )
        user_id = fields.Many2one(
            "res.users",
            "Librarian",
            default=lambda s: s.env.user,
        )
        request_date = fields.Date(
            default=lambda s: fields.Date.today(),
        )
    ```

Next we need to add data files, access rules, menu items, and some basic views so that the module can be used.

1. Add access permission configuration in the **security/ir.model.access.** **csv** file:


    ```
    id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
    checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1
    ```

1. Next, add **views/library_menu.xml** to implement the menu items:


    ```
    <odoo>
        <record id="action_library_checkout" model="ir.actions.act_window">
            <field name="name">Checkouts</field>
            <field name="res_model">library.checkout</field>
            <field name="view_mode">tree,form</field>
        </record>
        <menuitem id="menu_library_checkout"
                  name="Checkout"
                  action="action_library_checkout"
                  parent="library_app.menu_library" />
    </odoo>
    ```

1. The view implemented in the **views/checkout_view.xml** file:


    ```
    <odoo>
        <record id="view_tree_checkout" model="ir.ui.view">
            <field name="name">Checkout Tree</field>
            <field name="model">library.checkout</field>
            <field name="arch" type="xml">
                <tree>
                    <field name="request_date" />
                    <field name="member_id" />
                </tree>
            </field>
        </record>
        <record id="view_form_checkout" model="ir.ui.view">
            <field name="name">Checkout Form</field>
            <field name="model">library.checkout</field>
            <field name="arch" type="xml">
                <form>
                    <sheet>
                        <group>
                            <field name="member_id" />
                            <field name="request_date" />
                            <field name="user_id" />
                        </group>
                    </sheet>
                </form>
            </field>
        </record>
    </odoo>
    ```

Now that the module contains the above files, you can install it in the development database:

[![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/795b2447b8ab4f3085f4346afbc0ad6f~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage /wp-content/uploads/2022/06/2022061104121031.jpg)

**Figure 8.1**: Initial book borrowing function

Now we can start adding more interesting features.

Throughout the development of the project, we will continue to add business logic in different places to demonstrate the functions provided by Odoo. The next section will discuss some of them.

## How to trigger business logic

Once the data model is ready, business logic is needed to perform some automated operations. Business logic can be initiated directly by the user, such as clicking a button, or automatically triggered by an event, such as writing in a record.

This type of business logic mostly involves reading and writing record sections. Detailed techniques are discussed in [Chapter 7 Odoo 15 Development Record Set - Using Model Data](7.md), where we provide tools to implement the actual business logic.

The next question is how the business logic should be triggered. This depends on when and why the business logic is triggered. Below is a partial summary.

Some business logic is closely related to model field definitions. Some examples of business logic related to model definitions are as follows:

- **Data validation rules**: force data to meet certain conditions. Such methods are decorated with **@api.constrains**.
- **Automatic calculation**: implemented as a field (virtual or stored field), whose value is calculated by the method. This type of method is decorated with **@api.depends** and then assigned to the **compute** field attribute.
- **Default value**: can be calculated dynamically. This type of method uses **@api.model** to decorate and assign the value to the **default** field attribute.

Model definition logic is discussed in [Chapter 6 Odoo 15 Development Model - Structuring Application Data](6.md). Related examples can be seen in the **Data Model Pattern** section. The **Recordset ORM Method Decorators** section provides a review of some of the ORM decorators mentioned here.

There is also model event-related business logic, which is related to business workflow. It can be associated with the following record-related events:

- You can add **create**, **write**, **delete** business logic to these events, while other more elegant methods cannot be used.
- Apply **Onchange** logic to UI views so that the values ​​of some fields can be changed when other fields change.

For actions initiated directly by the user, the following options are available:

- The button view element is used to call object methods. Buttons can be located in a form or list view.
- **server** actions are available in menu items or in the **Action** context menu.
- A **window** action to open a wizard form, which can be input by the user, and the button will call the business logic. This makes the user interaction richer.

These techniques are used throughout this chapter. Supported methods are often implemented using API decorators, so it is important to understand the difference between them. To help clear the confusion, we'll provide an overview in the next section.

## Understanding the Recordset ORM method decorator

You can add **@** before the method definition to decorate the method. These decorators add specific behaviors to the method. Different decorators can be used depending on the function of the method.

### Calculated field and validation method decorators

- **@api.depends(fld1,...)** is used for calculated field functions to mark what kind of modification should be triggered by (re)calculation. It must be set on the calculated field value, otherwise an error will be reported.
- **@api.constrains(fld1,...)** is used in model validation functions and performs checks when fields contained in any parameters are modified. Modifications should not be written in the data, and an exception is thrown if the check fails.

This has been discussed in detail in [Chapter 6 Odoo 15 Development Model - Structured Application Data](6.md).

Another set of decorators affects the behavior of the **self** recordset and is related to the business logic implemented.

### Decorator that affects the self recordset

The default method should be used for the recordset provided by the first parameter self. The method code usually contains a for statement looping through each record in the self recordset.

> **CHANGES IN ODOO 14**
>
> The **@api.multi** decorator has been removed in Odoo 14. Previously, it was used to explicitly mark that the decorated method should be passed a set of records in the **self** parameter. It was already the default behavior of the method, so it was added only for clarity. The **@api.one** decorator was already deprecated in Odoo 9, so it was also removed in Odoo 14. It was used to handle record iteration, so the method was called for each record, and the **self** parameter was always a singleton. Starting from Odoo 14, both decorators have been removed from the code and are no longer supported.

In some cases, methods need to operate on a class rather than a specific record, like static methods. These methods are decorated with **@api.model**, and the **self** method parameter should be a pointer to the model, not a record.

For example, the create() method uses the @api.model decorator, which does not require an input record, but only a dictionary of values ​​to create and return the record. Methods used to calculate default values ​​also use the @api.model decorator.

Before we delve further into the business logic implementation, we must take a closer look at the data model, and along the way, provide some examples of common data model patterns.

## Exploring some data model patterns

Models are used to represent business documents with some required data structure. You can see them in some Odoo applications, such as **Sales Order** or **Invoice**.

A common pattern is to use a header/branch data structure. This is used in borrowing requests so that multiple books can be borrowed. Another pattern is to use states or stages. There are differences between these two, which we will discuss later and provide a reference implementation.

Finally, the ORM API provides some methods related to the user interface, which are discussed in this section.

### Using the header and branch models

A common requirement for form views is a header-branch data structure. For example, a sales order contains multiple order items. For borrowing functionality, a borrowing request can have multiple request lines, with each line being a borrowing item.

This is very simple to implement in Odoo. Two models are needed to implement the header line form view, one for the document header and one for the document lines. The line model is a many-to-one field that identifies the header it belongs to, while the header model has a one-to-many field that lists the lines in the document.

The **library_checkout** module has been added to the borrowing model. Now you need to add a branch. The steps are as follows:

1. Edit the **models/library_checkout.py** file and add a one-to-many field for the borrowing branch:


    ```
        line_ids = fields.One2many(
            'library.checkout.line',
            'checkout_id',
            string="Borrowed Books",
        )
    ```

1. Add the new model file in **`models/__init__.py`** as follows:


    ```
    from .import library_checkout
    from .import library_checkout_line
    ```

1. Then, add the Python file `models/library_checkout_line.py` that declares the borrowing branch model, with the following content:


    ```
    from odoo import api, exceptions, fields, models
    class CheckoutLine(models.Model):
        _name = "library.checkout.line"
        _description = "Checkout Request Line"
        checkout_id = fields.Many2one(
            "library.checkout",
            required=True,
        )
        book_id = fields.Many2one("library.book", required=True)
        note = fields.Char("Notes")
    ```

1. We must add access permission configuration. Edit the **security/ir.model.access.csv** file and add the following highlighted content:


    ```
    id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
    checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1
    checkout_line_user,Checkout Line User,model_library_checkout_line,library_app.library_group_user,1,1,1,1
    ```

1. Then, we need to add a checkout line to the form. Add it as the first page of the notebook widget. Edit the **views/checkout_view.xml** file and add the following code before the ` </sheet> ` element:


    ```
            <notebook>
                <page name="lines">
                    <field name="line_ids" >
                        <tree editable="bottom">
                            <field name="book_id" />
                            <field name="note" />
                        </tree>
                    </field>
                </page>
            </notebook>
    ```

The borrowing form is updated as follows:

[![Figure 8.2: Borrowing form with notebook widget](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/72f156ac4b8144fab98bc7fd3f67c5ea~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/06/2022061108305993.jpg)

**Figure 8.2**: Borrowing form with notebook widget

A one-to-many field is displayed as a list view in the parent form view. By default, Odoo looks for a list view definition to render, which is typical for any list view. If no definition is found, a default definition is automatically generated.

You can declare specific views inside a ` <field> `. This is what is done in the code above. Inside the **line_ids** field element, there is an embedded ` <tree> ` view definition that is used in the form.

### Using Phases and States with Document-Centric Workflows

In Odoo, we can implement workflows centered around documents. The documents we are talking about here include sales orders, project tasks, or personnel applications. All of them follow a specific life cycle and they are created when they are completed. Each work item is recorded in a document and progresses through a series of stages until it is completed.

If you present the stages as columns in a panel, and place the documents as work items in those columns, you get a Kanban board, a quick view of the progress of work.

There are two ways to implement these progress steps - states and stages:

- **State** is a predefined closed list of options. It is convenient to implement business rules because they can be fixed in advance. Models and views have special support for state fields, making them easy to use. A closed state list has a disadvantage that it cannot adapt to custom process requirements.
- **Stage** is implemented via an association model, which is a flexible list of steps that can be configured to suit the needs of the process. It is usually implemented using the **stage_id** field name. The list of stages can be easily modified because we can delete, add or reorder them. Its disadvantage is that it is not reliable for process automation. Because the list of stages can be modified, automation rules cannot rely on specific stage IDs or descriptions.

When designing a data model, we need to decide whether we should use stages or states. If triggering business logic is more important than configuring the process, states should be preferred, otherwise stages should be preferred.

If you can't decide, there is a way to have the best of both worlds: we can use stages and map them to corresponding states. The list of process steps can be easily configured by the user, and each stage will be associated with some reliable status codes, which can be easily used to automate business logic.

The book checkout feature will use this approach. To implement the checkout stage, we need to add the **library.checkout.stage** model. The fields required to describe the stage are as follows:

- **Name** or title
- **Sequence**, used to sort the stage column
- **Fold**, for Kanban view, determines whether the column is collapsed by default. This is usually used for inactive item columns, such as completed or cancelled.
- **Active**, allows stages to be archived or no longer used to prevent process changes.
- **State**, a closed selection list used to map each stage to a fixed state.

To implement the above fields we should add a **Stages** model, including model definitions, views, menus, and access permissions:

1. Add the **models/library_checkout_stage.py** file and include the following model definition code:


    ```
    from odoo import fields, models
    class CheckoutStage(models.Model):
        _name = "library.checkout.stage"
        _description = "Checkout Stage"
        _order = "sequence"
        name = fields.Char()
        sequence = fields.Integer(default=10)
        fold = fields.Boolean()
        active = fields.Boolean(default=True)
        state = fields.Selection(
            [("new", "Requested"),
             ("open", "Borrowed"),
             ("done", "Returned"),
             ("cancel", "Canceled")],
            default="new",
        )
    ```

    The above code should be familiar to the reader. The stages have a logical order, so the order of presentation is very simple. This is achieved by **_order="sequence"**. We also see that the **state** field maps each stage to a basic state, which can be safely used in business logic.

1. As usual, add a new code file in the **models/__init__.py** file as follows:


    ```
    from .import library_checkout_stage
    from .import library_checkout
    from .import library_checkout_line
    ```

1. Access rights rules are also required. Stages contain setup data and should only be edited by the **Administrator** user group. Regular users have read-only access. Therefore, add the following highlighted code to the **security/ir.model.access.csv** file:


    ```
    id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
    checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1
    checkout_line_user,Checkout Line User,model_library_checkout_line,library_app.library_group_user,1,1,1,1
    checkout_stage_user,Checkout Stage User,model_library_checkout_stage,library_app.library_group_user,1,0,0,0
    checkout_stage_manager,Checkout Stage Manager,model_library_checkout_stage,library_app.library_group_manager,1,1,1,1
    ```

1. Next, you need a menu item to view the stage settings. This should be located under the **Configuration** menu of the application. The **library_app** module does not have this menu yet, so you need to edit it and add it. Edit the **library_app/views/library_menu.xml** file and add the following XML:


    ```
        <menuitem id="menu_library_configuration"
                  name="Configuration"
                  parent="menu_library"
        />
    ```

1. Now add the **Stages** menu item to the **Configuration** menu. Edit the **library_checkout/views/library_menu.xml** file and add the following XML:


    ```
        <record id="action_library_stage" model="ir.actions.act_window">
            <field name="name">Stages</field>
            <field name="res_model">library.checkout.stage</field>
            <field name="view_mode">tree,form</field>
        </record>
        <menuitem id="menu_library_stage"
                  name="Stages"
                  action="action_library_stage"
                  parent="library_app.menu_library_configuration" />
    ```

1. We need some stages of operation, so add some default data to the module. Create the **data/library_checkout_stage.xml** file and add the following code:


    ```
    <odoo noupdate="1">
        <record id="stage_new" model="library.checkout.stage">
            <field name="name">Draft</field>
            <field name="sequence">10</field>
            <field name="state">new</field>
        </record>
        <record id="stage_open" model="library.checkout.stage">
            <field name="name">Borrowed</field>
            <field name="sequence">20</field>
            <field name="state">open</field>
        </record>
        <record id="stage_done" model="library.checkout.stage">
            <field name="name">Completed</field>
            <field name="sequence">90</field>
            <field name="state">done</field>
        </record>
        <record id="stage_cancel" model="library.checkout.stage">
            <field name="name">Canceled</field>
            <field name="sequence">95</field>
            <field name="state">cancel</field>
        </record>
    </odoo>
    ```

1. You need to add it in the `library_checkout/__manifest__.py` file to take effect, as follows:


    ```
        'data':[
            'security/ir.model.access.csv',
            'views/library_menu.xml',
            'views/checkout_view.xml',
            'data/library_checkout_stage.xml',
        ],
    ```

After a successful update, the stage list should look like the following:

[![Figure 8.3: Stage list view](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a4dc87930c1426493f0e61b32943a40~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/06/2022061111200367.jpg)

Figure 8.3: Stage list view

This is the stage model that needs to be added in **library_checkout**, which can also be configured by the user.

### Add stage workflow support model

Next, we should add a stage field to the book borrowing model. To ensure user experience, we need to deal with two more issues:

- The default stage should be assigned the **new** state.
- When grouping stages, all available stages should be present, even those that are not on loan.

These should be added in the **Checkout** class in the **library_checkout/models/library_checkout.py** file.

The function that finds the default phase should return the record used for the default value:

```
    @api.model
    def _default_stage_id(self):
        Stage = self.env["library.checkout.stage"]
        return Stage.search([("state", "=", "new")], limit=1)
```

This will return the first record in the stage model. Since the stage model is sorted by sequence number, it will return the record with the lowest sequence number.

When grouping by phase, you will see all phases, not just those with borrowed records. The method used returns the set of records used by the group. In this case, it is appropriate to return all active phases:

```
    @api.model
    def _group_expand_stage_id(self, stages, domain, order):
        return stages.search([], order=order)
```

Finally, we want to add a stage_id field to the borrow model, using the same approach as above for the default and group_expand attributes:

```
    stage_id = fields.Many2one(
        "library.checkout.stage",
        default=_default_stage_id,
        group_expand="_group_expand_stage_id")
    state = fields.Selection(related="stage_id.state")
```

**stage_id** has a many-to-one association with the stage model. The default value is calculated by the **_default_stage_id** method, and the grouping by **stage_id** uses the result of the **_group_expand_stage_id** method.

> Changes in ODOO 10
>
> The **group_expand** attribute was introduced in Odoo 10 and was not available in previous versions.

The **group_expand** parameter overrides the way the field is grouped. The default behavior of the grouping operation is to only view the stages in use, and those stages without borrowed documents are not displayed. But for the **stage_id** field, we want all available stages to be displayed, regardless of whether there is content or not.

The **_group_expand_stage_id()** helper method returns a list of grouped records used by the group operation. In this case, it returns all existing stages, regardless of whether they contain book records or not.

> Note: The **group_expand** attribute must be a method name string. It is different from other attributes, such as the **default** attribute, which can directly reference a method name or use a string.

A **state** field has also been added. It's just a stage-dependent **state** field in the model to use in the view. This uses the special support for **state** available in the view.

### Supported methods for the user interface

The following methods are most commonly used in web clients to render the user interface and perform basic interactions:

- **name_get()** computes the display name, which is the file representing each record used to display the associated record in the view. It returns the ID and a list of **(ID, name)** tuples. It is the default source of **display_name** values ​​and can be extended to implement custom displays, such as displaying the record name and identifier.
- **name_search(name='', args=None, operator='ilike', limit=100)** performs a search on display names. It is used for user input in the associated field of the view to generate a list of recommended records that match the entered text. It returns a list of tuples **(ID, name)**.
- **name_create(name)** creates a new record with only the entered name. This is used in conjunction with **on_create="quick_create"** in kanban views where the associated record can be quickly created by providing a name. Can be extended to provide specified default values ​​for new records created by this function.
- **default_get([fields])** Returns the default values ​​for creating new records as a dictionary. The default values ​​depend on variables such as the current user or session context. It can be extended to add additional default values.
- **fields_get()** is used to describe the definition of model fields, which can also be seen in the View Fields option in the developer menu.
- **fields_view_get()** is used in web clients to get the structure of the UI view to be rendered. You can pass in the view ID or the view type you want to use (view_type='form') as a parameter. For example, **self.fields_view_get(view_type='tree')** returns the XML structure of the tree view rendered for the **self** model. .

These built-in ORM methods serve as extension points for implementing model business logic.

In the next section we discuss how record operations (such as creating or writing a record) trigger business logic.

## Using ORM built-in methods

Model definition related methods can complete many tasks, but cannot implement some business logic, so ORM record writing operations are required.

ORM provides methods to perform CRUD operations on model data. Let's explore these write operations and how to extend them to support custom logic.

The main methods for reading data, search() and browse(), have been discussed in Chapter 7, Recordsets for Odoo 15 Development - Using Model Data.

### Method to write model data

The ORM provides three methods for three basic write operations, as follows:

- **<Model>.create(values)** creates a new record on the model, **values** is a dictionary or a list of dictionaries when creating records in batches.
- **<Recordset>.write(values)** Updates the recordset using the **values** dictionary and does not return a value.
- **<Recordset>.unlink()** Deletes the record from the database and does not return a value.

The **values** parameter is a dictionary mapping the field names and values ​​to be written. These methods are decorated with **@api.multi**, but the **create()** method uses **@api.model**.

> **Changes in Odoo 12**\
> create() can access a list of dictionaries instead of just a single dictionary object, which was introduced in Odoo 12. This allows us to create data in batches. This feature is supported by the **@api.model_create_multi** decorator.

In some cases, we need to extend these methods to run some specific business logic when the method is triggered. This business logic can be before or after the main method is executed.

#### Example of inheriting the create() method

Let's learn an example. We don't allow newly created borrowing records to be directly changed to the borrowed or returned state. Usually, applications use a method decorated with **@api.constrains** to implement validation. However, this example only creates a record event binding, which is difficult to implement with conventional validation.

Edit the **library_checkout/models/library_checkout.py** file and add the **create()** inherited method:

```
    @api.model
    def create(self, vals):
        # Code executed before creation, the vals dictionary should be used
        new_record = super().create(vals)
        # Code executed after creation should use new_record
        if new_record.stage_id.state in ('open', 'close'):
            raise exceptions.UserError("State not allowed for new checkouts.")
        return new_record
```

New records are created by the **super().create()** call. Before this, the new record cannot be used in the business logic, only the **values** dictionary can be used, and it cannot be modified to force some values ​​in the record to be created.

The code after **super().create()** has access to the newly created record and can use record functionality, such as using dot notation to chain related records. The above example uses **new_record.stage_id.state** to access the state corresponding to the new record stage. The state is not user-configurable and provides a stable list of values ​​for business logic. Therefore, we can look for **open** or **done** states and throw an error when found.

#### Example of inheriting write()

Let's look at another example. The **Checkout** model should record the date the book was checked out, the date it was borrowed, the date it was returned, and the date it was closed. This cannot be achieved using calculated fields. Instead, the **write()** method should be inherited to monitor changes in the borrowing status, and then update the date at the corresponding moment (when it changes to **open** or **done** status).

Before implementing this logic, you need to create two date fields. Edit the **library_checkout/models/library_checkout.py** file and add the following code:

```
    checkout_date = fields.Date(readonly=True)
    close_date = fields.Date(readonly=True)
```

When a record is modified, the checkout_date and close_date fields should be set when the borrowing record enters the corresponding state. To do this, we need to customize the write() method as follows:

```
    def write(self, vals):
        # Write the previous code, self is the old value
        if "stage_id" in vals:
            Stage = self.env["library.checkout.stage"]
            old_state = self.stage_id.state
            new_state = Stage.browse(vals["stage_id"]).state
            if new_state != old_state and new_state == "open":
                vals["checkout_date"] = fields.Date.today()
            if new_state != old_state and new_state == "done":
                vals["close_date"] = fields.Date.today()
        super().write(vals)
        # Write the following code to use the updated self
        return True
```

In the example above, the extension code is added before the call to super(), and therefore before writing the self record. To know the changes to be made to the record, you can look at the vals parameter. The stage_id in the vals dictionary is an ID number, not a record, so you need to scan for the corresponding record and then read the corresponding status.

Compare the old state and the new state to trigger the date value update at the corresponding moment. If possible, we prefer to modify the written value and update the vals dictionary before **super().write()**, rather than setting the field value directly. The reason will be explained in the next section.

#### Example of inheriting write() to set field values

The preceding code only modifies the value for writing; it does not assign values ​​directly to model fields. This is safe, but not enough in some cases.

Assigning a value to a model field inside a write() method will cause an infinite loop: the assignment will trigger the write method again, which will repeat the assignment, and so on, until Python returns a recursion error.

There is a trick to avoid recursive loops and allow the **write()** method to set the value of the record field. The trick is to set a unique flag in the environment context before setting the value, and only run the code to set the value if there is no flag.

It will be clearer if we look at the example. We rewrite the previous example so that the update is done after calling **super()**:

```
    def write(self, vals):
        # Write the previous code, self is the old value
        old_state = self.stage_id.state
        super().write(vals)
        # Write the following code to use the updated self
        new_state = self.stage_id.state
        if not self.env.context.get("_checkout_write"):
            if new_state != old_state and new_state == "open":
                self.with_context(_checkout_write=True).write(
                    {"checkout_date": fields.Date.today()})
            if new_state != old_state and new_state == "done":
                self.with_context(_checkout_write=True).write(
                    {"close_date": fields.Date.today()})
        return True
```

With this technique, the extension code is guarded by an if statement and is executed only if the context does not have the specified tag. In addition, the write is performed using the self.write() operation with the with_context method. This combination ensures that the code in the if statement is run only once and will not be triggered again by future write() calls, avoiding infinite loops.

#### When (not) to inherit create() and write() methods

Careful consideration should be given when inheriting from the create() and write() methods.

In most cases, you must perform some validation or automatically calculate some values ​​when saving a record. For these common cases, there are some better options, listed below:

- Use calculated fields for field values ​​that are automatically calculated based on other fields, such as calculating the total of a header when the value of each row changes.
- For non-fixed field default values, use a method as the default field value. The calculation will be performed when assigning the default value.
- Modify the value of another field when the value of one field changes, either in the UI, using the onchange method, or on the server, using a new writable computed field. For example, when the user selects a customer, we can automatically set the price list to that of the customer, although it can be modified by the user later. When using the onchange method, it only works for form view interactions and not for direct writes, but writable computed fields work for both cases. This is discussed in more detail in the Adding onchange UI Logic section.
- Validation uses the **constraint** method. It is automatically triggered when the field value is modified, and an error will be thrown if the validation conditions are not met.

There are also some cases where none of these options are applicable and you need to inherit from **create()** or **write()**, such as when the default value you set depends on other fields of the record being created. In this case, the default value method cannot be used because it cannot access other fields of the new record.

### Data import and export methods

Import and export operations are discussed in [Chapter 5 Odoo 15 Development: Importing, Exporting, and Module Data](5.md), and can also be performed through the following methods in the ORM API:

- **load([fields], [data])** is used to import data and is used by Odoo when importing CSV or table data. The first parameter is the list of fields to import, corresponding to the first line of the CSV. The second parameter is a list of records, each record is a list of strings to be parsed and imported. Directly corresponding to the rows and columns in the CSV data, it implements the features of CSV data import, such as support for external identifiers.
- **export_data([fields], raw_data=False)** Export function for web clients. It returns a dictionary with the data key containing **datas** (a list of rows). Field names can use the .id and /id suffixes used by CSV files, and the data format is compatible with the CSV file being imported. The optional raw_data argument makes the data values ​​exported with Python types instead of as strings in the CSV file.

It is also possible to automate the user interface while the user is editing data. We will learn how in the next section.

## Add onchange UI logic

The web client view can be modified when the user is editing. This mechanism is **onchange**. It is implemented by methods with **@api.onchange** decorator, and is triggered by the user interface view when the user edits a specific field.

Starting from Odoo 13, the same effect is achieved using a special form of calculated fields, called **writable calculated fields**. This ORM improvement aims to avoid the limitations of the classic onchange mechanism and, in the long run, replace it completely.

### Classic onchange method

The onchange method can modify other values ​​in the form, perform validation, display a message to the user, or set a domain filter on the associated field to limit the available options.

The onchange method is called asynchronously and returns data that is used by the web client to update the fields in the current view.

onchange is associated with the triggered field, and the field is passed as a parameter to the **@api.onchange("fld1", "fld2", ...)** decorator.

> **Note**: **api.onchange** parameters do not support dot notation, such as **"partner_id.name"**. If used, it will be ignored.

In this method, the **self** parameter is a virtual record containing the current form data. It is virtual because it can be a new record or a modified record when it is being edited but not saved to the database. If you set a value on the **self** record, it will be modified in the UI form. Note that it is not written to the database record, but provides information to modify the data in the UI form.

> **Note**: The onchange method has some other limitations, please refer to the [official documentation](https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html#odoo.api.onchange). Writable computed fields can be used as a full-featured replacement for the onchange method. See the **New onchange with writable computed fields** section for details.

No return value is required, but a **dict** structure may be returned with warning messages for display in the user interface, or to set field filters for forms.

Let's take an example. In the borrowing form, when the book membership is selected, the request date is modified to the current day. If the date changes, a warning message will be displayed to the user to inform the user of the change.

To implement this logic, edit the **library_checkout/models/library_checkout.py** file and add the following code:

```
    @api.onchange("member_id")
    def onchange_member_id(self):
        today_date = fields.Date.today()
        if self.request_date != today_date:
            self.request_date = today_date
            return {
                "warning": {
                    "title": "Changed Request Date",
                    "message": "Request date changed to today!",
                }
            }
```

The above **onchange** method is triggered when the **member_id** field is set in the user interface. The actual method name does not matter, but the convention is to prefix the field name with **onchange_**.

Inside the onchange method, self represents all the records that are currently set when editing a record, and we can interact with it.

The method code checks to see if the current **request_date** needs to be modified. If so, it sets **request_date** to today so that the user can see the change in the form. It then returns a non-blocking warning message to the user.

**onchange** does not need to return anything, but can return a field containing a warning or scope key, as follows:

- The key of the alert should describe the message displayed in the dialog, such as **{'title': 'Message Title', 'message': 'Message Body'}**
- Scope keys can set or modify the domain properties of other fields. This makes the user interface more friendly by only showing the fields that make sense at the moment for multiple fields. Scope keys look like this: **{'user_id': [('email', '!=', False)]}**

### New onchange with writable computed fields

The classic onchange mechanism plays a key role in the user experience provided by the Odoo framework. But it has some important drawbacks.

One is that it is not associated with server-side events. onchange only works when the form view is requested, but it is not called when the actual **write()** value changes. This requires the server-side business logic to re-close the relevant onchange method.

Another shortcoming is that onchange is related to the triggering field, but the modified field is not bound. For some small use cases, it is difficult to expand and track the source of the modification.

To solve these problems, the Odoo framework has extended the functionality of calculated fields to handle onchange use cases. We call this technique writable calculated fields. Classic onchange is still supported, but will be replaced and deprecated in future versions by calculated fields.

> **Changes in ODOO 13**
>
> Writable calculated fields were introduced in Odoo 13 and can be used in this version and later versions

Writable computed fields have computed methods assigned to them, must be stored, and must have the readonly=False attribute.

We use this method to implement the previous onchange. The **request_date** field should be modified as follows:

```
    request_date = fields.Date(
        default=lambda s: fields.Date.today(),
        compute="_compute_request_date_onchange",
        store=True,
        readonly=False,
    )
```

This is a regular storable and writable field, but with a calculation method bound to it that can be triggered by a specified condition. For example, the calculation method should be triggered when **member_id** changes.

The code of the calculation method **_compute_request_date_onchange** is as follows:

```
    @api.depends("member_id")
    def _compute_request_date_onchange(self):
        today_date = fields.Date.today()
        if self.request_date != today_date:
            self.request_date = today_date
            return {
                "warning": {
                    "title": "Changed Request Date",
                    "message": "Request date changed to today!",
                }
            }
```

**@api.depends** declares the fields to monitor for changes, just like for computed fields. The actual list of fields provided is the same as that used by the classic **@api.onchange**.

The method code is also very similar to the onchange method. In some cases it is identical. Note that the calculated field is not guaranteed to be set on every method call. It only happens when certain conditions are met. In this case, the original request date is different from today's date. This is different from the normal calculated field rules, but can be used for writable calculated fields.

Functionality that is strongly related to business processes is sending emails or notifying users. The next section discusses the functionality that Odoo provides for this.

## Message and activity functions

Odoo comes with global messaging and activity planning capabilities, provided by the **Discuss** application, technically known as **mail**.

The mail.thread model provides messaging functionality, with a messaging widget in the form view, also known as Chatter. This widget allows us to take notes or send messages to other users. It also saves the history of sent messages and is used by automated processes to record process tracking messages.

The same application also provides activity management functionality through the **mail.activity.mixin** model. You can add activity mail to the form view so that users can plan and track activity history.

### Adding message and event functions

The mail module provides the **mail.thread** abstract class for adding messaging functionality to any model. It also provides **mail.activity.mixin** for adding activity planning functionality. In [Chapter 4 Odoo 15 Development: Module Inheritance](4.md), we have explained how to use the inheritance of the mixin abstract class to add these inherited functions to the model.

The necessary steps to perform are as follows:

1. Edit the **depends** key in the `library_checkout/__manifest__.py` file to add the **mail** module dependency to the **library_checkout** plugin model, as follows:


    ```
        'depends': ['library_member', 'mail'],
    ```

1. To make the **library.checkout** model inherit the message and activity abstract classes, edit the **library_checkout/models/library_checkout.py** file as follows:


    ```
    class Checkout(models.Model):
        _name = "library.checkout"
        _description = "Checkout Request"
        _inherit = ["mail.thread", "mail.activity.mixin"]
    ```

1. Add message and action fields to the checkout form view, edit **library_checkout/** and **views/checkout_view.xml** files:


    ```
        <record id="view_form_checkout" model="ir.ui.view">
            <field name="name">Checkout Form</field>
            <field name="model">library.checkout</field>
            <field name="arch" type="xml">
                <form>
                    <sheet>
                        <group>
                            <group>
                                <field name="member_id" />
                                <field name="request_date" />
                                <field name="user_id" />
                            </group>
                            <group>
                                <field name="stage_id" />
                                <field name="checkout_date" />
                                <field name="close_date" />
                            </group>
                        </group>
                        <notebook>
                            <page name="lines">
                                <field name="line_ids" >
                                    <tree editable="bottom">
                                        <field name="book_id" />
                                        <field name="note" />
                                    </tree>
                                </field>
                            </page>
                        </notebook>
                    </sheet>
                    <div class="oe_chatter">
                        <field name="message_follower_ids" widget="mail_followers" />
                        <field name="activity_ids" widget="mail_activity" />
                        <field name="message_ids" widget="mail_thread" />
                    </div>
                </form>
            </field>
        </record>
    ```

Once this is done, the Borrowing model has message and activity fields and is ready for use.

### Message and Event Fields and Models

The message and activity features add new fields to models that inherit the **mail.thread** and **mail.activity.mixin** classes, as well as all models that support these features. The following are the basic data structures that have been added.

The **mail.thread** mixin class adds two new fields:

- **Followers**: **message_follower_ids** has a one-to-many association with **mail.follower**, storing the message followers who receive notifications. A follower can be a user or a channel. **partner** represents a person or organization. **channel** is not a person, but a subscription list.
- **Message**: **message_ids** has a one-to-many association with **mail.message** records, listing the recorded historical messages.

**mail.activity.mixin** The following fields are added to the mixin class:

- **Activity**: **activity_ids** has a one-to-many association with **mail.activity** and stores completed or planned activities.

### Message Subtype

Messages can have subtypes added to them. Subtypes are used to identify specific activities, such as tasks being created or closed, and are useful for precisely controlling what messages are sent to whom.

Subtypes are stored in the mail.message.subtype model and can be configured via the **Settings** > **Technical** > **Email** > **Subtypes** menu.

The three basic message subtypes are as follows:

- **Discussion**: with **mail.mt_comment** XML ID, used for messages sent by **Send message** in the message widget, and notifications will be sent to followers by default.
- **note**: with **mail.mt_note** XML ID, used to create a message with **Log note** XML ID, no notification will be sent by default.
- **Activities**: with **mail.mt_activities** XML ID, used to create a message with a link to the Schedule activity, without sending a notification.

You should be able to add your own subtypes, usually associated with related activities. For example, the **Sales** application adds two subtypes: **Quote Sent** and **Sales Order Confirmed**. These events are used by the business logic of the application when recording them in the message history.

Subtypes allow us to decide when and to whom notifications are sent. The Followers menu in the upper right corner of the message widget allows us to add or remove followers, as well as select the subtypes to receive notifications. The following image shows the subtype selection form for a follower, Gemini Furniture:

[![Figure 8.4: Follower widget with active message subtype selected](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d551378d19524b56ae0009c83c86a90b~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/06/2022061202245014.jpg)

**Figure 8.4**: Follower widget with active message subtype selected

Subtype subscription flags can be dragged and edited, and their default value is configured when editing the subtype definition and viewing the **Default** field. Once set, followers of new records will receive notifications by default.

In addition to built-in subtypes, plugin modules can add their own subtypes. Subtypes can be global or specific to a specific model. For the latter, the subtype's **res_model** field marks the model to which it applies.

### Send a message

Module business logic can use this messaging system to send notifications to users.

You can use the **message_post()** method to send a notification. The following is an example:

```
self.message_post('Hello!')
```

The above code adds a normal text message, but does not send a notification to followers. This is because the default message is posted using **Log a Note** with **subtype="mail.mt_note"** parameter.

To have the message also send a notification, you need to use the mail.mt_comment subtype, as shown in the following example:

```
self.message_post(
    'Hello again!',
    subject='Hello',
    subtype = 'mail.mt_comment')
```

The message body is in HTML format, so we can add tags to achieve text effects, such as `<b>` for bold and `<i>` for italics.

The message body is sanitized for security reasons, so some HTML elements may not end up in the message.

### Add followers

There is also a useful feature from a business logic perspective: you can add followers to a document so that they can get the corresponding notifications. We have the following methods to add followers:

- **message_subscribe(partner_ids=<integer id list>)** add partner
- **message_subscribe(channel_ids=<integer id list>)** add channel
- **message_subscribe_users(user_ids=<integer id list>)** add user

The default subtype will be applied to every subscriber. To force a subscription to a specified subtype list, add the **subtype_ids=<integer id list>** attribute to list the specified subtypes to be used in the subscription. If this attribute is used, the existing subscriber's subscription subtype will also be reset to the specified subtype.

## Create Wizard

Wizards are user interface patterns that provide rich interactions for users and are often used to provide input for automated processes.

For example, our borrowing module provides a wizard for book users to send batch emails to borrowers. For example, you can select the earliest borrowers of a book and send them a message asking them to return the book.

Our user starts by selecting the record to use from the borrowing list, then selects the Send Messages option from the Action context menu. This opens a wizard form that lets the user write the message subject and content. Clicking the Send button sends an email to everyone who has borrowed the selected book.

### Wizard Model

A wizard is presented to the user as a form view, usually a dialog box, with some fields to fill in, and buttons that trigger some business logic that is then used in the wizard logic.

It is implemented with the same model/view structure as normal views, but the supported models inherit from models.TransientMode instead of models.Model. This type of model is also reflected in the database to store state. The wizard's data is temporary to allow the wizard to complete its task. There is a scheduled task that periodically clears old data from the wizard's data table.

We will use the **wizard/checkout_mass_message.py** file to define the fields for interacting with the user: the list of loan records to be notified, the title, and the message body.

Follow the steps below to add a wizard to the **library_checkout** module;

1. First edit the `library_checkout/__init__.py` file and import the **wizard/ sub-directory as follows:


    ```
    from . import models
    from . import wizard
    ```

1. Add the file `wizard/__init__.py` and add the following code:


    ```
    from .import checkout_mass_message
    ```

1. Then create the actual **wizard/checkout_mass_message.py** file with the following content:


    ```
    from odoo import api, exceptions, fields, models
    class CheckoutMassMessage(models.TransientModel):
        _name = "library.checkout.massmessage"
        _description = "Send Message to Borrowers"
        checkout_ids = fields.Many2many(
            "library.checkout",
            string="Checkouts"
        )
        message_subject = fields.Char()
        message_body = fields.Html()
    ```

Now we have the basic data structures needed for the wizard.

Note that regular models should not have fields that relate to temporary models.

The result is that temporary models cannot have a one-to-many association with regular models. The reason is that a one-to-many association with a temporary model would require a reverse many-to-one association with the regular model, which would cause problems when automatically cleaning up temporary records.

An alternative is to use a many-to-many association. A many-to-many association is stored in a separate table, and when one side of the association is deleted, the corresponding row in the table is automatically deleted.

### Wizard Access Permissions

Like normal models, temporary models also need to define access rights rules. The implementation method is the same as that of normal models, that is, usually implemented in the **security/ir.model.access.csv** file.

> **Changes in ODOO 13**
>
> As of Odoo 12, temporary models did not require access rights rules. This has been changed in Odoo 13, so now temporary models require access rights rules just like normal models.

To add access permission list to the wizard model, edit the **security/ir.model.access.csv** file and add the highlighted code:

```
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1
checkout_line_user,Checkout Line User,model_library_checkout_line,library_app.library_group_user,1,1,1,1
checkout_stage_user,Checkout Stage User,model_library_checkout_stage,library_app.library_group_user,1,0,0,0
checkout_stage_manager,Checkout Stage Manager,model_library_checkout_stage,library_app.library_group_manager,1,1,1,1
checkout_massmessage_user,Checkout Mass Message User,model_library_checkout_massmessage,library_app.library_group_user,1,1,1,1
```

One line is enough to add full permissions to the Librarians group; no permissions need to be specified for the Librarians group.

### Wizard Form

A wizard form view is the same as a normal model, except that it has two specific elements:

- You can use the **<footer>** element to replace the action button
- **special="cancel"** button is used to interrupt the wizard and do nothing

The contents of the wizard/checkout_mass_message_wizard_view.xml file are as follows:

```
<odoo>
    <record id="view_form_checkout_message" model="ir.ui.view">
        <field name="name">Library Checkout Mass Message Wizard</field>
        <field name="model">library.checkout.massmessage</field>
        <field name="arch" type="xml">
            <form>
                <group>
                    <field name="message_subject" />
                    <field name="message_body" />
                    <field name="checkout_ids" />
                </group>
                <footer>
                    <button type="object" name="button_send" string="Send Messages" />
                    <button special="cancel" string="Cancel" class="btn-secondary" />
                </footer>
            </form>
        </field>
    </record>
    <record id="action_checkout_message" model="ir.actions.act_window">
        <field name="name">Send Messages</field>
        <field name="res_model">library.checkout.massmessage</field>
        <field name="view_mode">form</field>
        <field name="binding_model_id" ref="model_library_checkout" />
        <field name="binding_view_types">form,list</field>
        <field name="target">new</field>
    </record>
</odoo>
```

The XML code above adds two data records, one for the wizard form view and another for the action that opens the wizard.

**ir.actions.act_window** window action records are added in the **Action** context menu using the **binding_model_id** field value.

Don't forget to add this file in your declaration file:

```
    'data':[
        'security/ir.model.access.csv',
        "wizard/checkout_mass_message_wizard_view.xml",
        'views/library_menu.xml',
        'views/checkout_view.xml',
        'data/library_checkout_stage.xml',
    ],
```

The wizard form is as follows:

[![Figure 8.5: Send Message Wizard Form](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42d6d8f6690b4081ad238e6615d8c8f0~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/06/2022061203343248.jpg)

**Figure 8.5**: Send Message Wizard Form

**Translator's Note**: At this point, the update module will report an error because we have not yet implemented the button_send method. You can first add an empty method to complete the installation

To open the wizard, the user should select one or more records in the borrowing list view and choose the Send Messages option from the Action menu located above the list view.

### Wizard business logic

At this point we can open the wizard form, but we can't yet perform any actions on the records. First we want the wizard to display the list of records we selected in the Borrowing List view.

When you open the wizard form, it displays an empty form. It is not a record yet and will become a record only when you click a button to call a method.

> **Note**: When the wizard form is opened, we have an empty record. The **create()** method has not yet been called, which requires a button press. Therefore, it cannot be used to set the value displayed in the wizard form.

You can add data to an empty form by setting default values ​​for the fields. **default_get()** is the ORM API method responsible for calculating the default values ​​for the record. You can extend it to add business logic as follows:

```
    @api.model
    def default_get(self, field_names):
        defaults_dict = super().default_get(field_names)
        # Add values ​​to defaults_dict here
        return defaults_dict
```

The above method can be used to add a default value to the **checkout_ids** field. But we also need to know how to access the list of selected records in the original list view.

When entering a window from a client window, the web client will store some data of the original view in the environment's **context**. The data is as follows:

- **active_model**: the technical name of the model
- **active_id**: The ID of the active record in the form or the first record in the accessed list view
- **active_ids**: a list containing the selected records (only one element if it is a form)
- **active_domain**: When the action is triggered in the form view

In this example, **active_ids** can be used to get the ID of the selected record in the list view and set a default value for the **checkout_ids** field. The **default_get** method is as follows:

```
    @api.model
    def default_get(self, field_names):
        defaults_dict = super().default_get(field_names)
        checkout_ids = self.env.context["active_ids"]
        defaults_dict["checkout_ids"] = [(6, 0, checkout_ids)]
        return defaults_dict
```

First, **super()** is used to call the framework's **default_get()** implementation, which returns a dictionary containing the default values. Then the **checkout_id** key is added to **defaults_dict**, and the **active_ids** value is read from the environment context.

In this way, when the wizard form is opened, the **checkout_ids** field will automatically add the selected record to the business. Next, you need to implement the function of the **Send Messages** button of the form.

Looking at the XML code of the form, we can see that the button calls a method called **button_send**. It should be defined in the **wizard/checkout_mass_message.py** file as follows:

```
    def button_send(self):
        self.ensure_one()
        for checkout in self.checkout_ids:
            checkout.message_post(
                body=self.message_body,
                subject=self.message_subject,
                subtype_xmlid="mail.mt_comment"
            )
        return True
```

This method is used to operate a single record. It cannot be used normally when **self** is a record set. **self.ensure_one()** is used here to show the instructions.

Here **self** represents the wizard record data created when the button is clicked. It contains the data entered in the wizard form. Validation is performed to ensure that the user enters the message body text.

The **checkout_ids** field is accessed and each record in it is iterated over. For a single borrowing record, a message is submitted using the **mail.thread** API. Notification emails sent to record followers must use the **mail.mt_comment** subtype. The message content and subject are extracted from the **self** record field.

It is a good practice to have methods return something, or at least return True. The reason is that some XML-RPC clients do not support None values. When Python methods do not have an explicit return, None is implicitly returned. In practice, this may not be a problem, because web clients use JSON-RPC, not XML-RPC, but it is still a good practice.

Wizards are the most complex tools in our business logic workbox and the techniques detailed in this sheet.

Business logic also includes testing whether conditions are met before and after performing certain operations. The next section explains how to throw exceptions when conditions are not met.

## throw an exception

Sometimes the input is not suitable for the task being performed and the code needs to alert the user with an error message and interrupt program execution. This is achieved by throwing an exception. The exception classes provided by Odoo are used at this time.

The most commonly used Odoo exceptions are:

```
from odoo import exceptions
raise exceptions.ValidationError("Inconsistent data")
raise exceptions.UserError("input error")
```

The **ValidationError** exception is used for validation in Python code, such as methods decorated with **@api.constrains**.

**UserError** should be used in all other cases where the operation is not allowed because it does not conform to business logic.

> **Changes in Odoo 9**\
> The UserError exception is introduced to replace the Warning exception. The reason for eliminating the Warning exception is that it conflicts with Python's built-in exceptions, but Odoo retains it to maintain backward compatibility.

Usually, all data operations during method execution are in the same database transaction, which will be rolled back when an exception occurs. That is, when an exception is thrown, all previous changes to the data will be canceled.

Let's use the button_send method in this example wizard to illustrate. Imagine if it is illogical to execute the message sending logic without selecting any borrowed documents. It is also illogical to send a message without a message body. Let's warn the user when these situations occur.

Edit the button_send() method and add the following highlighted code:

```
    def button_send(self):
        self.ensure_one()
        if not self.checkout_ids:
            raise exceptions.UserError("No checkouts were selected")
        if not self.message_body:
            raise exceptions.UserError("A message body is required")
        for checkout in self.checkout_ids:
            checkout.message_post(
                body=self.message_body,
                subject=self.message_subject,
                subtype_xmlid="mail.mt_comment"
            )
        return True
```

When using exceptions, make sure to import it at the top of your code file with from odoo import exceptions. Adding validations simply requires checking if some condition is met and throwing an exception if it is not.

The next section discusses development tools that every Odoo developer should be very familiar with. We start with automated testing.

## Writing unit tests

Automated testing is a widely accepted best practice in software development. It not only helps us ensure that the code is implemented correctly, but more importantly, it provides a safety net for future code modifications and rewrites.

For dynamic programming languages ​​like Python, since there is no compilation step, syntax errors are often not easy to notice. This also makes it more important to have unit tests to detect code errors, such as incorrectly typed identifier names.

The following two goals are our beacons when writing tests. The first goal of testing should be test coverage: write test cases to exercise all lines of code.

This usually greatly promotes the second goal, namely the correctness of the code. This is because after improving the test coverage, we have a basis for building test cases for large use cases.

> ℹ️Changes in Odoo 12\
> Prior to this version, Odoo also supported testing via YAML data files. The YAML data file engine was removed in Odoo 12 and this format is no longer supported. The last documentation about this format can be found on the official website.

Next we will learn how to add test cases to the module and run them.

### Add unit tests

Tests for plugin modules must be placed in a **tests/** subdirectory. The test runner will automatically look for test files in this directory, and it should not be imported in the module's top-level `__init__.py`.

To add tests to the wizard logic of the **library_checkout** module, we can create `tests/__init__.py` and import the test file in it. In this example, it should contain the following code:

```
from .import test_checkout_mass_message
```

Then, we need to create the tests/test_checkout_mass_message.py file and make sure it follows the basic structure of the unit test code:

```
from odoo import exceptions
from odoo.tests import common


class TestWizard(common.SingleTransactionCase):
    def setUp(self,*args, **kwargs):
        super(TestWizard, self).setUp(*args, **kwargs)
        # Add test configuration code here

    def test_01_button_send(self):
        """The Send button should create a message for the borrowing record"""
        # Add test code
```

Odoo provides some classes for testing:

- **TransactionCase** Use a different transaction for each test, which is automatically rolled back at the end of the test.
- **SingleTransactionCase** runs all tests in one transaction and rolls back after the last test is finished. This can greatly increase the test speed, but each test needs to be written in a compatible way.

These test classes are encapsulations of the Python standard library unittest test cases. For more details, please refer to the [official documentation](https://docs.python.org/3/library/unittest.html).

The setUp() method is used to prepare test data and store it in class attributes for later use by test methods.

Tests are implemented as class methods, such as **est_01_button_send()** in the sample code. Test case method names must be prefixed with **test_** so that they can be discovered by the test executor. Test methods are executed in the order of their method names.

The docstring method is printed in the server log when running tests and is used to provide a brief description of the tests executed.

### Running the tests

Once you have written your tests, you can run them. You must upgrade or install the module (-I or -u) and add the --test-enable option to the Odoo server command.

The command is as follows:

```
(env15) $ odoo -c library.conf --test-enable -u library_checkout --stop-after-init
```

Only installed or upgraded modules are tested, which is why the -u option is used. If some dependencies need to be installed, their tests will also be run. If you do not want to test dependencies, install the new module first, and then run the tests when upgrading the module (-u).

Although the module contains test code, the code here does not execute any tests and will run successfully. If you look carefully at the server log, there will be an INFO message reporting the test run, similar to the following:

```
INFO library odoo.modules.module: odoo.addons.library_checkout.tests.test_checkout_mass_message running tests.
```

The basic structure of the test code is in place. Now let's add the actual test code. First we should configure the data.

### Configuration test

The first step in writing a test is to prepare the data to be used. This is usually done in the **setUp** method. This example requires a borrowing record to be used when testing the wizard.

It is convenient to perform test operations with a specific user, so that you can also test whether the permission control is configured correctly. This is achieved through the **sudo(<user>)** model method. The recordset carries this information, so after it is created with **sudo()**, subsequent operations on the same recordset will be executed with the same context.

The following is the code in the **setUp** method:

```
class TestWizard(common.SingleTransactionCase):
    def setUp(self,*args, **kwargs):
        super(TestWizard, self).setUp(*args, **kwargs)
        # Configure test data
        admin_user = self.env.ref("base.user_admin")
        self.Checkout = self.env["library.checkout"].with_user(admin_user)
        self.Wizard = self.env["library.checkout.massmessage"].with_user(admin_user)
        a_member = self.env["library.member"].create({"partner_id": admin_user.partner_id.id})
        self.checkout0 = self.Checkout.create({"member_id": a_member.id})
```

At this point we can use the self.checkout0 record and the self.Wizard model in our tests.

### Writing test cases

Now let's extend the **test_button_test()** method in the initial framework.

Basic testing is to run some code in the test object, get the results, and then use assert statements to compare with the expected results. The message sending logic does not return any value, so other methods are needed.

The **button_send()** method adds a message to the message history. One way to determine if this has occurred is to count the number of messages before and after the method is executed. The test code can count the message data before and after the wizard. The following code adds this logic:

```
    def test_01_button_send(self):
        """The Send button should create a message for the borrowing record"""
        count_before = len(self.checkout0.message_ids)
        # TODO: Run the wizard
        count_after = len(self.checkout0.message_ids)
        self.assertEqual(
            count_before + 1,
            count_after,
            "Expected one additional message in the Checkout.",
        )
```

This check verifies whether the test succeeded or failed in a self.assertEqual statement. It compares the number of messages before and after running the wizard, expecting one more message than before. The last parameter is used as a message prompt when the test fails. It is optional, but recommended.

The **assertEqual** method is just one type of assertion method. We should choose the appropriate assertion method based on the specific use case. The **unittest** documentation provides a description of all these methods, see the Python [official documentation](https://docs.python.org/3/library/unittest.html#test-cases).

Running a wizard is not straightforward enough, we need to simulate the UI workflow. Remember that the environment context uses **active_ids** to pass data to the wizard. We must create a wizard record with the data filled in the wizard form, which is the message title and content used by the **button_send** method.

The complete code is as follows:

```
    def test_01_button_send(self):
        """The Send button should create a message for the borrowing record"""
        count_before = len(self.checkout0.message_ids)
        Wizard0 = self.Wizard.with_context(active_ids=self.checkout0.ids)
        wizard0 = Wizard0.create({
            "message_subject": "Hello",
            "message_body": "This is a message.",
        })
        wizard0.button_send()
        count_after = len(self.checkout0.message_ids)
        self.assertEqual(
            count_before + 1,
            count_after,
            "Expected one additional message in the Checkout.",
        )
```

The **with_context** model method is used to add **active_ids** to the environment context. Then the **create()** method is used to create the wizard record and add the user input data. Finally, the **button_send** method is called.

More test cases can be added using other methods in the test class. Remember that when using TransactionCase tests, each test is rolled back at the end, undoing all actions performed during the test. Tests are additive in SingleTransactionCase, and the order of tests is important. Because tests are executed in alphabetical order, the selected test methods are relevant. For clarity, it is good practice to add numbers before the test method names, which is what is done in the previous example.

### Test exception

Sometimes the code should throw an exception, which should also be tested. For example, we can test whether the validation is performed correctly.

Continuing with the wizard testing, a check is performed to see if the message body is empty. You can add a test to check if the validation is performed correctly.

Check if the director is thrown, the corresponding code should be placed in the **with self.assertRaises()** code block.

Add another test as follows:

```
    def test_02_button_send_empty_body(self):
        """Send button reports an error when the message body is empty"""
        Wizard0 = self.Wizard.with_context(active_ids=self.checkout0.ids)
        wizard0 = Wizard0.create({})
        with self.assertRaises(exceptions.UserError) as e:
            wizard0.button_send()
```

If the button_send() method does not throw a UserException, the test will fail. If an exception is thrown, the test will succeed. The thrown exception is stored in the variable e and can be inspected by other method commands, such as verifying the content of the error message.

## Using log messages

Writing messages to log files helps in monitoring and auditing a running system. It also helps in code maintenance by making it easy to get debug information from a running process without modifying the code.

To use the logging function in Odoo code, you must first prepare a logger object. Add the following code to the top of the **library_checkout/wizard/checkout_mass_message.py** file:

```
import logging
_logger = logging.getLogger(__name__)
```

The Python standard library **logging** module is used here. **_logger** is initialized with the current code file name `__name__`. In this way, the log information will contain the information of the generated log file.

There are several levels of log information:

```
_logger.debug('DEBUG debugging message')
_logger.info('INFO information log')
_logger.warning('WARNING warning message')
_logger.error('ERROR error message')
```

Now you can use the logger to write messages to the Odoo server log.

Let's add logging to the **button_send** wizard method. Add the following code before **return True** at the end of the file:

```
        _logger.info(
            'Posted %d messages to Checkouts: %s',
            len(self.checkout_ids),
            str(self.checkout_ids),
        )
```

In this way, when you use the wizard to send a message, a message similar to the following will be printed in the server log:

```
INFO library odoo.addons.library_checkout.wizard.checkout_mass_message: Posted 2 messages to the Checkouts: [3, 4]
```

Notice that we don't use Python string interpolation, or the % operator, in our log messages. Specifically, instead of using _logger.info('Hello %s' % 'World') , we use something like _logger.info('Hello %s', 'World') . Not using interpolation saves our code one task, making logging more efficient. So we should always pass in variables for additional logging parameters.

Timestamps in server-side logs are always in UTC. This may surprise you, but Odoo servers internally use UTC to handle dates.

For debug level logging, we use **_logger.debug()** . For example, you can add the following debug log message after **checkout.message_post()** command:

```
        _logger.debug(
            'Message on %d to followers: %s',
            checkout.id,
            checkout.message_follower_ids)
```

This will not display any messages in the server log, because the default log level is INFO. You need to set the log level to DEBUG to output debug log messages.

The Odoo command line option `--log-level` can be used to set the general log level. For example, use `--log-level=debug` to enable debug log messages from the command line.

We can also set the log level for a specific module. To turn on debug messages for the wizard, use the `--loghandler` option, which can be repeated multiple times to set the log level for multiple modules.

For example, our wizard's Python module is **odoo.addons.library_checkout.wizard.checkout_mass_message**e, which can also be seen in the **INFO** log messages. To set it to debug log level, use the following command line argument:

```
--loghandler=odoo.addons.library_checkout.wizard.checkout_mass_message:DEBUG
```

A complete guide to Odoo server logging options can be found in the official documentation.

> Tip: If you want to know the original Python logging details, you can refer to the Python [official documentation](https://docs.python.org/3/library/logging.html) first.

Logs are useful tools, but they are not enough when debugging. There are other tools and techniques that can assist developers in their work. We will learn about them in the next section.

## Learn some development tools

There are tools that can make the developer's life easier. One of them is the developer mode in the user interface, which we introduced earlier in this book. You can also use this option on the server to provide more developer-friendly features. We will explain it in detail below. Then we will discuss how to debug the server code.

### Server Development Options

The Odoo server provides a `--dev` option to enable developer features and speed up the development process, for example:

- Break into the debugger when an exception is found in a plugin module. This is done by configuring the debugger. Defaults to **pdb**.
- Automatically reload the code when saving Python files, avoiding repeated manual restarts of the server. This can be achieved with the **reload** option.
- Read view definitions directly from XML files, without having to update modules manually. This can be done with the **xml** option.
- A Python debugging interface for use directly in a web page. This is enabled via the **werkzeug** option.

The `--dev` parameter accepts a comma separated list of options. Use `--dev=all` to enable all of these options.

When the debugger is enabled, the Odoo server uses it by default, but other options are available if other debuggers are installed on the system. The supported debuggers are as follows:

- **ipdb**: See <https://pypi.org/project/ipdb> for details
- **pudb**: See <https://pypi.org/project/pudb> for details
- **wdb**: See <https://pypi.org/project/wdb> for details

When editing Python code, each time you modify the code you need to restart the server to reload the code for use in Odoo. The `--dev=reload` option automatically reloads the code. When enabled, the Odoo server monitors the changes made to the code files and automatically triggers a code reload, making the code changes take effect immediately.

To run properly, the **watchdog** Python package is required, which can be installed using the following command:

```
(env15) $ pip3 install watchdog
```

The `--dev=all` option also enables reloading, which is used in most cases:

```
(env15) $ odoo -c library.conf --dev=all
```

Note that this is only useful for changes to Python code. For other changes, such as model data structures, a module upgrade is required and reloading is not enough.

### debug

Most of the work of developers is debugging code. It is very convenient to set breakpoints and debug step by step.

Odoo is a server that runs Python code and waits for client requests. The requests are processed by the corresponding server code and then a response is returned to the client. In other words, debugging of Python code is done on the server. Breakpoints are enabled on the server and the server execution of that line of code is paused. Therefore, setting breakpoints and operating the debugger require developers to complete them in the terminal window.

#### Python Debugger

The simplest debugging tool is the Python integrated debugger **pdb**. But other options have richer user interfaces, close to advanced IDEs.

There are two ways to trigger the debugger popup.

One is when an unhandled exception is thrown and the `--dev=all` option is enabled. The debugger will also stop code execution at the command that caused the exception. Developers can view the current variables and program statements to better understand the reasons behind it.

The other method is to edit the code and drag the breakpoint, and add the following line where the execution needs to be paused:

```
import pdb; pdb.set_trace()
```

This does not require --dev mode. You will need to reload the Odoo server to use the modified code. When the execution reaches the pdb.set_trace() command, a (pdb) Python popup will be displayed in the server terminal window, waiting for input.

**(pdb)** The popup window runs as a Python shell, and can execute any expression or command in the current execution context. This means that you can view or even modify the current variables.

There are several commands related to the debugger. The most important ones are:

- **h** (help) displays a summary of available pdb commands
- **p** (print) runs and prints an expression
- **pp** (pretty print) helps print data structures like dictionaries or lists
- **l** (list) lists the surrounding code to be executed next
- **n** (next) Go to the next command
- **s** (step) enter the current command
- **c** (continue) Continue normal execution
- **u** (up) move up in the execution stack
- **d** (down) moves down in the execution stack
- **bt** (backtrace) displays the current execution stack

The Python documentation contains a complete description of the pdb command.

#### Example Debug Session

To understand how to use the debugger features, let's look at what a debugger session looks like.

Add a debugger breakpoint on the first line of the **button_send()** wizard method, as follows:

```
    def button_send(self):
        import pdb; pdb.set_trace()
        self.ensure_one()
        # ...
```

After re-executing the service load, open the **Send Message** wizard form and click the **Send Messages** button. This will trigger the **button_send()** method on the server and pause at the breakpoint. The web client will be in the **Loading…** state, waiting for the server to respond.

At this point, the terminal running the server will display information similar to the following:

```
> /home/vagrant/odoo-dev/custom-addons/library_checkout/wizard/checkout_mass_message.py(24)button_send()
-> self.ensure_one()
(Pdb)
```

This is the pdb debugger dialog box, and the first two lines provide relevant information about the Python code execution paused. The first line shows the file, line number and function name, and the second line is the code to be executed next.

> **Tip**: During a debugging session, server-side log messages will appear randomly. Most of them come from the **werkzeug** module. They can be silenced by using the `--log-handler=werkzeug:WARNING` option on the Odoo command line. Another option to simplify general logging is `--log-level=warn`.

The **p** debug command prints out the result of an expression, while **pp** does the same but formats the output to be more readable, especially the **dict** and **list** data structures. For example, to print the value for the **checkout_ids** field that's used in the wizard, type the following:

At this point, type h to see a quick guide to available commands. Type l to display the current line of code and the surrounding code.

Typing n will run the current line of code and go to the next line. If you just press Enter, it will repeat the previous command.

The **p** debugging command prints the result of the expression, while the **pp** effect frame makes the output format more readable, especially for dictionary and list data structures. For example, to print the **checkout_ids** field used in the wizard, enter the following command:

```
(Pdb) p self.checkout_ids
library.checkout(30,)
```

The debug dialog can run Python commands and expressions. It supports arbitrary Python expressions, even assignments.

When you are done with the debugging session, press **c** to return to normal program execution. Sometimes you may want to interrupt the execution and press **q** to quit.

We can debug line by line and at any time press c to continue normal execution.

> **Tips:** When you return to the terminal window from the debugger, if the terminal is not responding, the input in the terminal will not be displayed. You can use the **reset** command to solve the problem by inputting **<enter>reset<enter>**.

#### Other Python debuggers

**pdb** has the advantage of being "out-of-the-box", it is simple but crude, and there are some more comfortable options to use.

ipdb (Iron Python debugger) is a common choice. It uses the same commands as **pdb**, but has made some improvements, such as adding tab completion and syntax highlighting to make it more comfortable to use. It can be installed with the following command:

```
pip3 install ipdb
```

Use the following command to add a breakpoint:

```
import ipdb; ipdb.set_trace()
```

![Odoo 12 debugging tool ipdb](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33ec1fe996a3428cbd701f14e5d3b9f7~tplv-k3u1fbpfcp-zoom-1.image)

Another alternative debugger is **pudb**, which also supports the same commands as **pdb**, only in a text terminal, but uses a graphical display similar to an IDE debugger. Useful information such as variables and values ​​of the current context is displayed in its own window on the screen.

```
sudo apt-get install python-pudb # Use Debian system package
pip3 install pudb # Use pip, which can be used in a virtual environment
```

Adding breakpoints is no different than **pdb**:

```
import pudb; pudb.set_trace()
```

A shorter and more concise way is also possible:

```
import pudb; pu.db
```

The above code is faster to type and also achieves the desired effect - adding a code execution breakpoint.

> Note: Starting with Python 3.7, breakpoints can be set using the breakpoint() method instead of pdb.set_trace() . Debug libraries can override the behavior of breakpoint() and call it directly. However, at the time of writing this book, pudb and ipdb do not yet do so, so there is no advantage to using breakpoint() .

### ![Odoo 12 debugging tool pudb](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/908aa5945f0a426e9d3754c054894e2c~tplv-k3u1fbpfcp-zoom-1.image)

### Print messages and logs

Sometimes we just need to check the value of some variables or whether some code snippet is executed. Python's print() command can perfectly solve these problems without interrupting the execution flow. The printed content is sent to standard output and is not stored in the server's log file.

**print()** functions are intended only to aid development and should not appear in the final deployed code. If **print** statements can also help identify problems in production, consider replacing them with debug-level log messages.

### View and close running processes

There are also some tips for viewing the running processes of Odoo.

First we need to find the corresponding process ID (**PID**). This number is printed after the timestamp of each log message. Another way to find the PID is to run the following command in another terminal window:

```
ps ax | grep odoo-bin
```

Example output is as follows:

```
2650 pts/5 S+ 0:00 grep --color=auto odoo
21688 pts/4 Sl+ 0:05 python3 /home/daniel/work15/env15/bin/odoo
```

The first column of the output is the PID of the process. In the above example, the PID of the Odoo process is **21688**.

Once you know the process PID, you can send information to the Odoo server process. Use the kill command to send information. By default, kill sends a signal to terminate the process, but you can also send other more friendly signals.

If you send a SIGQUIT or -3 signal, the Odoo server will print a stack trace of the code being executed:

```
kill -3 <PID>
```

After sending **SIGQUIT**, the Odoo server log will show a stack trace. Useful to understand which code was currently executed. This information is printed for each used string.

This is used in some code performance analysis to track where the server time is spent and perform performance analysis on the code. For information about code performance analysis, please refer to the [official documentation](https://www.odoo.com/documentation/15.0/howtos/profilecode.html).

Other signals that can be sent to the Odoo server process are: **HUP** to reload the service, **INT** or **TERM** to force the service to shut down, as follows:

```
kill -HUP <PID>
kill -TERM <PID>
```

The HUP signal is particularly useful for reloading the Odoo configuration without stopping the server.

## Summarize

In this chapter, we explored the various features of the ORM API and how to use these features to create dynamic applications that interact with users, which can help users avoid errors and automate some monotonous tasks.

Model validation and calculated fields can handle many use cases, but not all. We learned how to extend the create, write, and unlink methods of the API to handle more use cases.

For richer user interactions, we use the **mail** kernel plugin mixin to add functionality for users to communicate around documents and activity planning. Wizards allow applications to talk to users and collect the required data to run specific processes. Exceptions allow applications to terminate erroneous operations, inform users of the problem, and roll back intermediate changes to maintain system consistency.

We also discussed the tools that developers can use to create and maintain applications: logging messages, debugging tools, and unit testing.

In the next chapter, we will also use ORM, but we will operate from the perspective of an external application, using the Odoo server as the backend for storing data and running business processes.

## Further reading

The following are reference materials related to the content discussed in this article:

- [ORM Reference](https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html)
- [Message and event functions](https://www.odoo.com/documentation/15.0/developer/reference/backend/mixins.html)
- [Odoo Testing Reference](https://www.odoo.com/documentation/15.0/developer/reference/backend/testing.html)
- Python [Unit Testing Reference](https://docs.python.org/3/library/unittest.html#module-unittest)