# Chapter 5 Odoo 15 Development: Import, Export and Module Data

Most of the definitions of Odoo modules, such as user interfaces and permission rules, are actually data records stored in corresponding database tables. The XML and CSV files in the module are not used by the Odoo application runtime, but are a means to load these definitions into the database tables.

It is for this reason that an important part of an Odoo module is to put data in files so that it can be added to the database when the plugin is installed.

In addition, mastering the data presentation format of Odoo is also important for importing and exporting business data during project implementation.

The main contents of this chapter are:

- Understand the concept of external identifiers
- Import and export data files
- Using CSV files
- Add module data
- Using XML data files

After studying this chapter, readers can perform data import and export, add initial data to the database, and automatically create default and demonstration data for the created modules.

## Development Preparation

This chapter requires that the reader can run the Odoo service and has installed the book application we developed earlier.

For the relevant code, please see the ch05/** directory of the [GitHub repository](https://github.com/alanhou/odoo12-development/tree/master/custom-addons). It contains the library_app in [Chapter 3 Odoo 15 Development: Creating the First Odoo Application](3.md), as well as the new code in this chapter.

## Understanding the concept of external identifiers

External identifiers, also known as XML IDs, are human-readable string identifiers used to uniquely identify a specific record in Odoo. They are important when loading data in Odoo, so that you can modify an existing record or reference it in other records.

First we will discuss how external identifiers work and how to check for them. Then we will learn how to use the web client to look up the external identifier for a specific data record, which is often needed when creating plugin modules or extending existing functionality.

### How external identifiers work

Let's start with the principle of identification. The real identifier of a record in the database is an automatically assigned serial number, and the specific ID that will be assigned cannot be known in advance when the module is installed. External identifiers allow us to refer to a related record without knowing the real assigned database ID. XML ID provides a convenient alias for the database ID, which can be used to refer to a specific record at any time.

Odoo module data files use XML IDs to define records. One of the reasons is to avoid creating duplicate records when upgrading a module, which will load the data files into the database again. Instead of creating duplicate records, we want to detect existing records and update them.

Another reason to use XML IDs is to support cross-data: data records that need to reference other data records. Since we don't know the real database ID, using XML IDs allows the Odoo framework to handle the conversion transparently.

Odoo handles the conversion of external identifiers to the real database IDs assigned. The mechanism behind this is quite simple: Odoo maintains a table of mappings between external identifiers and corresponding database numeric IDs: the ir.model.data model.

We need to enable developer mode to access the menus below. You can check to see if there is a debug icon on the left side of the avatar in the upper right corner. If not, you need to enable it in the Settings menu page. For specific methods, please refer to the content in [Chapter 1 Using Developer Mode to Quickly Start Odoo 15](1.md).

You can view the existing mappings by accessing Settings > Technical > Sequences & Identifiers > External Identifiers through the menu. For example, if you access the external identifier list and filter out the library_app module, you will see the external identifier generated by the module, as shown in the following figure:

[![Figure 5.1: External identifier generated by library_app](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c8ef8286691459aaaec0e47d9259469~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022052007505911.jpg)

**Figure 5.1**: External identifier generated by library_app

You can see that the external identifier has the Complete ID tag. Note that its components are: module name + . + identifier name, such as library_app.action_library_book.

External identifiers only need to be unique within an Odoo module, and using the same identifier in two modules will not cause conflicts. The globally unique identifier is composed of the module name and the external identifier, which can be seen in the Complete ID field in the figure above.

When using external identifiers in data files, we can choose to use the full identifier or just the external identifier part. It is usually simpler to use only the external identifier, but using the full identifier allows us to reference data records in other modules. When doing so, don't forget to include these modules in the module dependencies to ensure that these records are loaded before our records.

Sometimes you need to use the full identifier even when referencing an XML ID in the same module.

At the top of the list in the above image, you can see the full identifier of **library_app.action_library_book**. This is the menu action we created in the module and referenced in the corresponding menu item. Click to enter the form view to view the details. As can be seen in the figure, the **action_library_book** external identifier in the **library_app** module is mapped to the record ID in the **ir.actions.act_window** model, which is **90** here.

Click the record row to see the form view as shown below:

[![Figure 5.2: Form view of external identifier](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e95f0353629844f8a86232a245bdab57~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022052007590154.jpg)

**Figure 5.2**: Form view of external identifier

In addition to being used to reference other records, external identifiers can also avoid duplicate data caused by repeated imports. Once an external identifier already exists, it will be updated on the original record, avoiding the creation of duplicate data.

### Finding external identifiers

When writing data records for our modules, we often need to look up existing external identifiers to reference, so it is important to know how to find these identifiers.

One way is to access the menu Settings > Technical > Sequences & Identifiers > External Identifiers, as shown in Figure 5.1 above. Another way is to use the developer menu. In [Chapter 1 Getting Started with Developer Mode in Odoo 15](1.md) it is described how to activate the developer mode in the lower right corner of the Settings panel.

To find the external identifier of a data record, we should open the corresponding form view, select the **Developer** menu, and then select the **View Metadata** option. A dialog box with the record database ID and external identifier (also called XML ID) will be displayed.

For example, to view the **demo** user ID, open the **demo** user form view through **Settings > Users & Companies > Users**, and then click the **View Metadata** option in the developer tools menu. You can now see that the XML ID is **base.user_demo** and the database ID is **6**:

[![Figure 5.3: View Metadata dialog window](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df4977aee9934121bfb14aba0906844c~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022052009252970.jpg)

**Figure 5.3**: View Metadata dialog window

To view the external identifier of a form, list, search, or action view element, use the developer menu. Next, open the details form of the corresponding view using the Edit View option. You can now view the External ID field, whose value is the external identifier.

For example, in the following figure, you can see that the external identifier of the user form view is **base.view_users_form**:

[![Figure 5.4: The Edit View window displays the external identifier of the form view](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd7ec3e40cc24229a44c4182c622738e~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022052009311543.jpg)

**Figure 5.4**: The Edit View window showing the external identifier of the form view

So far, we have learned about external identifiers and how to use them as aliases to reference database records. We have also learned several ways to find XML IDs, which are used when referencing records in data files. Next, we will learn how to create data files, which will use these XML IDs.

## Import and export CSV data files

An easy way to generate a data file and view its structure is to use the built-in export functionality.

The generated CSV file allows us to understand the data format required for manual import into the system, edit the file to perform a bulk import, or even use it to generate demo data for our plugin modules.

Let's learn the basics of importing and exporting data from the Odoo user interface.

### Exporting Data

Data export is a standard feature in list view. To use this feature, select the rows to be exported by checking the boxes on the left, then click the Export option in the Action menu above.

First we need to add some books with publishers and authors to the books application. In the following example I use the books I added previously.

We also need to install the **Contacts** app so that we can see the list view of Partners and export records from there. Note that the default view is the contact card board view, so you need to switch to the list view first:

[![Figure 5.5: Export options of the action menu](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87ef0dd621124826b0326edccae81e76~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022052010061932.jpg)

**Figure 5.5**: Export option in the Action menu

You can select all records that match the current search criteria by checking the checkbox in the column header.

> **Changes in Odoo 9**\
> In earlier versions of Odoo, only the records displayed on the screen (the current page) could be exported. Odoo 9 has made a change, checking the checkbox in the column header will export all matching records of the current filter, not just the currently displayed ones. This is very useful for exporting a large number of records that cannot be displayed on the screen.

Click the **Export** option to enter the **Export Data** dialog form, where you can choose what to export and how to export. We are more concerned about the export method so that we can import the file later manually or through the plug-in module:

[![Figure 5.6: Export Data Dialog Box Window](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61058d7b53cc400ba3a9fcc19846eee7~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022052010200293.jpg)

**Figure 5.6**: Export Data Dialog Window

- **I want to update data (import-compatible export)** : Check this checkbox to export data in a format that is friendly for later import.
- **Export format**: You can choose **CSV** or **XLSX**. We will choose **CSV** format to better understand the original export format, which can be read in many spreadsheet applications.

Next, select the columns to be exported. In this example, we simplify the operation and only select the **Name** field. We click the **Export** button and a file with the exported data will be downloaded. The final exported CSV file looks like this:

```
"id","name"
"__export__.res_partner_42_6fcf3f5d","Daniel Reis"
"__export__.res_partner_43_7ac40720","William Golding"
```

**Supplement:** Please note that the ID fields here and in the following sections are related to the exported system and should not be used directly.

The first row contains the field names, which are used to automatically match the catalog columns during import.

It is not surprising that the first row has the **name** column selected. The initial ID column was automatically added because the import-compatible export was selected.

The automatically added **id** column contains the external ID assigned to each record. This allows the exported data to be edited and updated records to be imported later without creating duplicate data.

Missing external identifiers are automatically generated using the `__export__` prefix, see the export example above.

> **Tip:** Since record identifiers are automatically generated, the export or import function can be used to bulk edit Odoo data: export the data to CSV, bulk edit the data using a form software, and then import it into Odoo.

### Importing data

Now that we have the data in the correct format, we can import it into Odoo. Let's learn how to do this through the web user interface.

First, make sure that the import function is enabled, which is enabled by default. If not, go to **Settings** > **General Settings** and check the **Import & Export** option under the **Permissions** section.

When this option is enabled, an **Import records** option appears in the **Favorites** menu next to the **Filters** and **Group By** menus in the list view search widget.

An Import button will appear next to the Create button above.

> **Note: The Import & Export** setting installs the **base_import** module, which is used to provide this functionality.

Let's try to batch edit the Contact or Partner data. Use a spreadsheet or text editor to open the CSV file you just downloaded and modify a few values. You can also add a few rows and leave the id column blank.

As mentioned above, the first column **id** is a unique identifier for each row, so that existing records can be updated without creating duplicate data when re-importing into Odoo. We edit any field in the export file and the corresponding record will be updated when importing.

For new rows to be added to the CSV file, we can either add an external identifier ourselves or leave the **id** column empty. Both methods will create a new record. As an example, let's add a row with **id** empty and name **Phillip K. Dick**, creating this new record in the database:

```
,Phillip K. Dick
```

After saving the CSV file, click the **Import** option in the **Favorites** menu. The page that appears allows you to upload the data file. Then the import assistant will appear:

[![Figure 5.7: Import File Assistant](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a13655ae6754cac85af7b7082906e33~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022052011360512.jpg)

**Figure 5.7**: Import File Assistant

During this period, you need to select a CSV file in the local disk and click the **Test** button in the upper left corner to test its correctness.

Since the imported file is an Odoo export, it is likely that the format is valid and the columns will map accordingly to the data table. Depending on the application you are editing the data file for, you may need to adjust the delimiter and encoding options to achieve the best results.

At this point, click **Import** and the changes made and the new records will be loaded into Odoo.

### Related records in CSV data file

The previous examples are very simple, but once we start using related fields to relate records from multiple tables, the data files will become more complex.

We have dealt with the Partner records in the book above. Now let's look at how to represent references to these Partners in the book CSV file. Specifically, there is a many-to-one (or foreign key) association with the publisher (**publisher_id** field), and a many-to-many association with the author (**author_ids** field).

The related column in the header row of the CSV file should have an **/id** added after the name. It will use the external identifier to reference the related record. In this example, we will load the book publisher in the **publisher_id/id** field, using the external ID of the related Partner as its value.

You can use **/.id** instead, which will use the real ID from the database (the automatically assigned numeric id), but this is rarely used. Unless you have a specific reason, use the external ID instead of the database ID. Also remember that the database ID is specific to the Odoo database, so it will usually fail if you import it into a non-native database.

Many-to-many fields can also be imported in CSV data files. This is as simple as adding a list of external IDs separated by commas and enclosed in double quotes. For example, to load book authors, you need an **author_ids/id** column with a comma-delimited list of associated Partner external IDs as its value. Here is an example of a many-to-many field in CSV:

```
id, name, author_ids/id
book_odc11, "Odoo 11 Development Cookbook", "__export__.res_partner_42_6fcf3f5d,__export__.res_partner_43_7ac40720"
```

One-to-many fields are usually table headers and rows or parent-child relationships. There is special support for this type of relationship: the same parent record can have multiple associated rows.

Here we have an example of a one-to-many field in the Partner model: a company can have multiple child contacts. If you export data from the Partner model and include the **Contacts/Name** field, you can see the format to import this type of data (select Azure Interior in Contacts: the default should be the first one, and perform the previous export steps):

| id | name | child_ids/id | child_ids/name |
| ------------------- | --------------- | --------------- ------------- | --------------- |
| base.res_partner_12 | Azure Interior | base.res_partner_address_15 | Brandon Freeman |
| | | base.res_partner_address_28 | Colleen Diaz |
| | | base.res_partner_address_16 | Nicole Ford |

[![Figure 5.8: Example of exporting a one-to-many relationship field data file](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c320176797f54ecbbdab2a6f6e5d39d4~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022052012055450.jpg)

**Figure 5.8**: Example of exporting a one-to-many relationship field data file

**id** and **name** are for parent records, **child_ids** are for child records. Note that the parent record section below the first row is left blank.

The CSV file format in the table above is shown as:

```
"id","name","child_ids/id","child_ids/name"
"base.res_partner_12","Azure Interior","base.res_partner_address_15","Brandon Freeman"
"","","base.res_partner_address_28","Colleen Diaz"
"","","base.res_partner_address_16","Nicole Ford"
```

You can see that the first row of the **id** and **name** columns has values, and the next two rows are empty. The parent record is the company information of the contact.

The other two rows are both prefixed with **child_ids/** and have data in all three rows. These are the contact information for the parent company. The first row contains the company and the first contact, and the remaining rows only contain data for the child contact columns.

## Add module data

The module uses data files to load default data, demonstration data, user interface definitions and other configurations that need to be stored in the database. You can choose to use CSV or XML files.

> **Changes in Odoo 12**\
> Odoo 11 and earlier versions support YAML format files, but related support is removed in Odoo 12. For related usage examples, please refer to the Odoo 11 official module **l10n_be**. For more information about the YAML format, please visit <http://yaml.org/>.

The CSV files used by the module are the same as the files we used when using the import function above. When using these files in the module, the file name must be consistent with the model name to be imported. For example, the CSV data file name imported into the **library.book** model should be **library.book.csv**.

CSV data files are often used to import the **ir.model.access** model to obtain permission definitions. They are usually placed in the **security/** subdirectory and named **ir.model.access.csv**.

### Demo Data

It is a good practice for Odoo add-on modules to install demo data. It can be useful to provide examples and test data sets for modules. Demo data for a module is declared via the **demo** attribute in the `__manifest__.py` file. Like the **data** attribute, it is followed by a list of file names with relative paths to the module.

We should add some demo data to the library.book module. An easy way to do this is to export the data from the development database where the module is installed.

By convention, data files are placed in the **data/** subdirectory and should be saved as **data/library.book.csv** in the **library_app** module. Because this data is owned by the module, the identifier prefix `__export__` should be removed in the exported data.

For example, the res.partner.csv file might look like this:

```
id,name
res_partner_alexandre,"Alexandre Fayolle"
res_partner_daniel,"Daniel Reis"
res_partner_holger,"Holger Brunn"
res_partner_packt,"Packt Publishing"
```

Then the book demonstration data file **library.book.csv** should look like this:

```
"id","name","date_published","publisher_id/id","author_ids/id"
library_book_ode11,"Odoo Development Essentials 11","2018-03-01",res_partner_packt,res_partner_daniel
library_book_odc11,"Odoo 11 Development Cookbook","2018-01-01",res_partner_packt,"res_partner_alexandre,res_partner
_holger"
```

Also remember to declare the data file in the **demo** attribute of `__manifest__.py`:

```
'demo': [
 'data/res.partner.csv',
 'data/library.book.csv',
],
```

Files are loaded in the order they are declared, which is important because records in a file cannot reference records that have not yet been created.

As long as you enable Install demo data, the content in the file will be imported the next time you update the module.

> **NOTE:** Data files are re-imported when the module is upgraded, but demo files are not, they are only imported at install time.

Of course, XML files can also be used to load or initialize data, and can also use functions that ordinary CSV files do not have. In the next section, we will discuss using XML formatted data files.

## Using XML data files

CSV files are a convenient and concise format for displaying data, but XML files are more powerful and provide more control during the loading process. For example, the file name does not need to be the same as the name of the model it is imported into. Because the XML format can provide richer information and more content through the XML elements within the file.

We have used XML data files in previous articles. User interface components such as views and menu items are actually records stored in the system model. The XML files in the module are used to load these records into the instance database.

We will add another data file **data/book_demo.xml** in the **library_app** module for display. The file content is as follows:

```
<?xml version="1.0"?>
<odoo noupdate="1">
    <!-- Data to load -->
    <record model="res.partner" id="res_partner_huxley">
        <field name="name">Aldous Huxley</field>
    </record>
    <record model="library.book" id="library_book_bnw">
        <field name="name">Brave New World</field>
        <field name="author_ids"
                eval="[(4, ref('res_partner_huxley'))]" />
        <field name="date_published">1932-01-01</field>
    </record>
</odoo>
```

As usual, new data files should be declared in `__manifest__.py`:

```
    "demo": [
        "data/res.partner.csv",
        "data/library.book.csv",
        "data/book_demo.xml",
    ],
```

Similar to the CSV data file in the previous section, this file also loads data into the Book model.

The XML file contains an outer ` <odoo> ` top-level element, which can contain multiple ` <record> ` elements, corresponding to the CSV data rows.

> **Note:** The outer ` <odoo> ` element in data files was introduced in 9.0 to replace the previous ` <openerp> ` tag. The ` <data> ` tag inside the outer element is still supported and is optional. In fact, ` <odoo> ` and ` <data> ` are now equivalent, and we can use either one as the outer element in the XML data file.

The ` <record> ` element has two mandatory attributes: **model** and **id** which is the external identifier of the record. Each field is written using a ` <field> ` tag.

Note that you cannot use slash marks in field names, for example, you cannot use ` <field name="publisher_id/id"> `. You should use the **ref** attribute to reference external identifiers. We will discuss the value of a to-many field in a moment.

You may have noticed the use of the noupdate="1" attribute in the <odoo> outer element. This prevents the data records from being loaded when the module is upgraded, so as not to lose the data edited subsequently.

### noupdate data attribute

When you upgrade a module, the data is reloaded and the module records are rewritten. Keep in mind that this may mean that any manual changes to the module data will be overwritten when you upgrade the module.

> **Tip:** It is worth noting that the custom changes made manually to the view will be lost at the next module upgrade. The correct way to avoid this problem is to create an inherited view to introduce the changes you want to make.

This override behavior is the default, but can be modified so that some data is only imported at install time and ignored on subsequent module updates. This is achieved by setting noupdate="1" in the <odoo> or <data> elements.

This is useful for data that needs to be initially configured and is expected to be customized, as these manual modifications are safe when the module is updated. For example, it is often used in record permission rules, which can be adapted to specific implementation needs.

You can have multiple ` <data> ` sections in the same **XML** file. You can use noupdate="1" to separate the data that you only need to import once, and the data that you need to re-import on each update ( **noupdate="0"** ). **noupdate="0"** is the default value, so it can be omitted. Note that there must also be an outer XML element. For this example, use two ` <data> ` tags and wrap them with an ` <odoo> ` or ` <data> ` element.

> **Tip: The noupdate** attribute may cause discomfort when developing a module, because subsequent modifications will be ignored. One solution is to reinstall the module using the **-i** parameter instead of the **-u** parameter. Reinstalling with the **-i** parameter from the command line will ignore the **noupdate** flag in the data record.

The **noupdate** flag is stored in the external identifier information for each record. It can be edited manually in the **External Identifiers** form in the **Technical** menu by checking the **Non Updatable** checkbox.

> **Changes in Odoo 12**\
> When you click **View Metadata** in the developer menu, the value of the **No Update** tag will be displayed below **XML ID** in the pop-up dialog box. You can also modify the value of the tag by clicking it there (only applicable to imported data).

### Defining records in XML

In the XML data file, each ` <record> ` element has two basic attributes: **id** and **model**, and contains ` <field> ` elements that set values ​​for the corresponding columns. The **id** attribute corresponds to the record external identifier, and **model** corresponds to the target model. There are several ways to assign values ​​to the ` <field> ` element, let's take a look at them together.

### Set the value of the field directly

The **name** attribute of the ` <field> ` element identifies the field to be written.

The value written is the element content: the text between the field opening and closing tags. For dates and time periods, use the **eval** property with an expression that returns a **date** or **datetime** object. The returned **"YYYY-mm-dd"** and **"YYYY-mm-dd HH:MM:SS"** strings are converted accordingly. For Boolean fields, **"0"** and **"False"** are converted to False, and any non-null value is converted to **True**.

> **Changes in Odoo 10**\
> The way to read Boolean values ​​**False** from data files has been improved in Odoo 10. In older versions, non-null values ​​including **"0"** and **"False"** were converted to **True**. Until Odoo 9, Boolean values ​​still had to be set using the **eval** attribute, such as **eval="False"**.

### Setting values ​​through expressions

A more complex way to set a field value is via the **eval** attribute. This will evaluate a Python expression and assign the result to the field.

Expressions are evaluated in the context of Python built-ins and some other identifiers that create expressions.

You can use the following Python modules to process dates: **time**, **datetime**, **timedelta**, and **relativedelta**. They can be used to calculate date values, which are often used in demonstrations and test data to make the date close to the module installation date. For more information about Python modules, please refer to the [official documentation](https://docs.python.org/3/library/datatypes.html).

For example, to set the value to the previous day, you can use the following code:

```
<field name="date_published"
    eval="(datetime.now() + timedelta(-1))" />
```

The evaluation context also has access to the ref() function, which is used to convert an external identifier into its corresponding database ID. This can be used to set values ​​for relational fields. For example, you can use it to set the value of publisher_id:

```
<field name="publisher_id" eval="ref('res_partner_packt')" />
```

### Setting values ​​on many-to-one relationship fields

For many-to-one association fields, the database ID of the associated record is written. In the XML file, we usually know the XML ID of the record, and then we need to convert it into the actual database ID.

One way is to use the eval attribute with the ref() function as before.

A simpler alternative is to use the **ref** attribute on the ` <field> ` element, for example:

```
<field name="publisher_id" ref="res_partner_packt" />
```

The above example sets the value of the many-to-one field **publisher_id**, referencing the database record with the XML ID **res_partner_packt**.

### Setting values ​​on to-many relationship fields

For one-to-many and many-to-many fields, we set not a single ID but a set of related IDs. And we also perform several operations: we may need to replace the current list of related records with another one, add a few records to it, or even delete some of them.

To support write operations on to-many fields, we use a special syntax in the **eval** attribute. We use a list of three-tuples to write to to-many fields. Each tuple has three elements, forming a write command, and performs the corresponding operation according to the code in the first element.

To rewrite the book author list, the following code would be used:

```
<field
    name = "author_ids"
    eval = "[(6, 0,
        [ref('res_partner_alexandre'),
        ref('res_partner_holger')]
    )]"
/>
```

To add related records to the current book author list, you need to add the following code:

```
<field name="author_ids"
    eval="[(4, ref('res_partner_daniel'))]"
/>
```

The above examples are very common. They all use only one command, but multiple commands can be chained in the outer list. Append(4) and Replace(6) are the most commonly used commands. When appending(4), the last element is not needed, so it is omitted in the above code.

The complete write-to-many command is as follows:

- **(0, _ , {'field': value})** creates a new record and associates it with
- **(1, id, {'field': value})** updates the value of the associated record
- **(2, id, _)** removes the association and deletes the record associated with id
- **(3, id, _)** removes the association but does not delete the record associated with id. It is usually used to delete the associated records of many-to-many fields.
- **(4, id, _)** Associates an existing record, only applicable to many-to-many fields
- **(5, _, _)** Delete all associations, but not the associated records
- **(6, _, [ids])** replaces the list of associated records with the list here

The underscore _ characters above represent irrelevant values, usually filled with 0 or False.

> **Tip:** The following non-associated values ​​can be safely omitted, such as (4, id, _) can be replaced with (4, id)

In this section, we learned how to use the ` <record> ` tag to load records into the database. There are also some shorthand tags that can be used to replace the regular ` <record> ` tag. We will introduce them in the next section.

### Abbreviations for commonly used models

If we go back to [Chapter 3 Odoo 15 Development: Creating the First Odoo Application](3.md), we also found elements other than ` <record> ` in the XML file, such as ` <menuitem> `.

These are shorthands for commonly used models, which are more concise than the commonly used ` <record> `. They are used to load data into the base model and compose the user interface. They will be discussed in more detail in [Chapter 10 Odoo 15 Development Background View - Design User Interface] (10.md).

For ease of viewing, here are the available shorthand elements and the corresponding models for loading data:

- ` <menuitem> ` corresponds to the menu item model ir.ui.menu
- `<template>` for QWeb templates stored in the ir.ui.view model

> **Changes in Odoo 14**\
> Previous versions of Odoo also supported other short tags, which are no longer supported. There were ` <act_window> ` for the window action model **ir.actions.act_window**, and ` <report> ` for the report action model **ir.actions.report.xml**.

It should be noted that when used to modify an existing record, the shorthand element overwrites all fields. This is different from the base ` <record> ` element which only writes to the provided fields. Therefore, the ` <record> ` element should be used when modifying specific fields of a user interface element.

## Other operations in XML files

So far we have learned how to add or update data using XML files. But you can also delete data and execute specified model methods through XML files. This will be very useful for more complex data scenarios. In the following sections, we will learn how to delete and use functions to call XML functions.

### Deleting records

We can delete data records using the ` <delete> ` element, using either an ID or a search scope to locate the record to be deleted.

For example, to find records using a search scope and delete them:

```
<delete
    model="res.partner"
    search="[('id','=',ref('library_app.res_partner_daniel'))]"
/>
```

If you know the specific ID of the record to be deleted, you can also use the **id** attribute. The above example is exactly like this, and it can also be written like this:

```
<delete model="res.partner" id="library_app.res_partner_daniel" />
```

This has the same effect as the previous example. Since we know the ID we want to find, we do not need to use the **search** attribute with a scope expression, but can use the **id** attribute directly with the XML ID.

### Calling model methods

XML files can also execute arbitrary methods during loading via the ` <function> ` element. This can be used to set up demonstration and test data.

For example, the **Notes** application bundled with Odoo uses it to set the demo data:

```
<data noupdate="1">
<function
    model="res.users"
    name="_init_data_user_note_stages"
    eval="[]" />
</data>
```

This calls the _init_data_user_note_stages method in the res.users model without passing any arguments. The argument list is passed via the eval attribute, which is an empty list here.

We have now learned about XML data files. We reviewed the ` <data> ` and the **noupdate** tag. We then learned how to load data files using the ` <record> ` element and how to set values ​​for associated fields. We also learned about record abbreviations, such as ` <menuitem> ` and ` <template> `. Finally, we learned how to delete records and call specified functions using ` <delete> ` and ` <function> `.

After learning these, readers should be able to prepare the required XML data files according to the project's data requirements.

## Summarize

In this chapter, we learned how to display data using text files. You can use them to manually import data into Odoo, or put them in plugin modules as default or demonstration data.

Through learning, we can export and import CSV data files through the web interface, as well as detect and update existing records in the database through external identifiers. It can also be used for batch editing of data, just edit the exported CSV file and re-import it.

We also took a detailed look at the structure of an XML data file and all the functionality it provides. Not only can we set values ​​for fields, but we can also perform operations such as deleting records and calling methods.

In the next chapter, we will focus on learning how to use records to work with the data contained in the model. These tools allow us to implement the business logic and rules of our application.

## Further reading

More information about data files is available in the [Odoo official documentation](https://www.odoo.com/documentation/15.0/developer/reference/backend/data.html).