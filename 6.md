# Chapter 6 Odoo 15 Development Model - Structured Application Data

In this chapter, we take a closer look at the model layer and how to use models to design the data structures that support your application. We'll explore the available model types and how to define constraints that enforce data validation when using these types.

Models are made up of data fields that support different data types. Some field types support defining relationships between models. More advanced uses of fields include automatically calculating values ​​using specific business logic.

The main contents of this article are:

- Learning Project- Optimizing Book Application
- Create Model
- Create Field
- Relationships between models
- Calculated fields
- Model constraints
- Overview of Odoo's base model

Through these contents, we will learn how to create large data structures for Odoo projects. After completing this chapter, readers should have a clear understanding of the functions related to the architecture data model.

## Development Preparation

The code in this article is based on the code created in [Chapter 3 Odoo 15 Development: Creating the First Odoo Application](3.md). For related code, see the **ch06/** directory of the [GitHub repository](https://github.com/iTranslateX/odoo-essentials/tree/main/source-code/).

Please add it to the plugin path and install the **library_app** module.

## Learning Project - Optimizing Book Application

In [Chapter 3 Odoo 15 Development: Creating the First Odoo Application](3.md), we created a library_app plugin module and implemented a simple library.book model to display the book catalog. In this chapter, we will return to this module to enrich the stored book data.

We use the following structure to add a classification level for book classification:

- Name: Category title
- Parent: The parent category
- Subcategories: This is a subcategory of the parent category.
- Featured book or author: The selected book or author in this category

We will add some fields to show the data types of fields in Odoo. We will also add some validation constraints to the book model:

- Title and publication date should be unique
- The ISBN entered should be a valid

Let's take a closer look at Odoo models and learn about all the options available to you.

## Create the model

Models are the core of the Odoo framework. They describe the data structure of the application and are the bridge between the server-side application and the database storage. Business logic can be implemented around models to add functionality to the application, and the user experience provided by the user interface is also built on top of the models.

In the following sections we will learn about common properties of models that affect behavior, as well as several types of models: regular models, transient models, and abstract models.

### Model properties

Model classes can use a number of other attributes that control behavior. The following are the most commonly used attributes:

- **_name:** It is the internal identifier of the Odoo model we created and is required when creating a new model.
- **_description:** It is a user-friendly title that refers to a single model record, such as **Book**. Optional but recommended. If not set, a warning will be displayed in the server log during the loading process.
- **_order:** Sets the default sorting when browsing model records or list views. Its value is the string used in the order by SQL statement, so you can pass in any value that conforms to SQL syntax. It has smart mode and supports translatable fields and many-to-one field names.

Our book model already uses the _name and _description attributes. We can add an _order attribute to sort by book name by default, and then sort by publication date in reverse order (newest first).

```
class Book(models.Model):
    _name = 'library.book'
    _description = 'Book'
    _order = 'name, date_published desc'
```

The following properties are also used in advanced use cases:

- **_rec_name:** The field that sets the record display name. The default is the **name** field, so we usually choose it as the record title.
- **_table:** is the name of the data table corresponding to the model. Usually it is set automatically by the ORM, replacing the dots in the model name with underscores, but we can specify the table name through this attribute.
- **_log_access=False:** Used to set the audit trail fields, namely **create_uid**, **create_date**, **write_uid** and **write_date**, not to be automatically created.
- **_auto=False:** Used to set the data table corresponding to the model not to be created automatically. In this case, the **init()** method should be used to write the specific logic for creating database objects, data tables or views. Usually used to support views for read-only reports.

For example, the following code sets some default values ​​for the **library.book** model:

```
    _recname = "name"
    _table = "library_book"
    _log_access = True
    _auto = True
```

> Note: There are also _inherit and _inherits attributes for inheriting modules, which will be studied in depth later in this article. They have been explained in detail in [Chapter 4 Odoo 15 Development Module Inheritance](4.md).

When using **_auto = False**, we are overloading the process of creating database objects, so we should write corresponding logic. A common scenario is reporting, based on database views that collect the data required for the report.

The following is an example extracted from the **sale** kernel module, from the **sale/report/sale_report.py** file:

```
    def init(self):
        tools.drop_view_if_exists(self.env.cr, self._table)
        self.env.cr.execute(
            "CREATE or REPLACE VIEW %s as (%s)"
            % (self._table, self._query())
        )
```

The above code uses the Python module **tools**, which needs to be imported using `from odoo import tools`.

### Models and Python classes

Odoo models use Python classes. In the previous code, there is a Python class that inherits the models.Model class: Book, which is used to define an Odoo model named library.book.

Odoo's models are stored in a central registry, which is accessible through the environment object, usually **self.env**. The central registry holds references to all models, accessed using a dictionary-like syntax.

For example, you can use **self.env['library.book']** or ****self.env.get(["library.book"])** within a method to get a reference to the Book model.

It can be seen that the model name is very important, it is the key to access the model registry.

Model names must be globally unique. Therefore it is good practice to use each word of the application to which the module belongs as the first word of the model name. For the **Library** application, all model names should use the **library** prefix. Other examples of kernel models are **project**, **crm**, or **sale**.

> **Tips:** Model names should use the singular form **library.book**, not **library.books**. The standard is to connect a group of lowercase words with a period. The first word identifies the main application, such as **library.book** or **library.book.category**. For example, the official plugin has **project.project**, **project.task**, and **project.task.type**.

In addition, Python class names are local to the Python file and have no relation to the Odoo framework. The names used only have meaning within that file and are not highly relevant. Python class names are written in CamelCase according to PEP8.

There are several types of models. The most commonly used one is the models.Model class, which is used to store models persistently in a database. Next we will learn about the other types of models.

### Transient and Abstract Models

Most classes in Odoo models inherit from the models.Model class. This type of model is stored persistently in the database, creating a table for the model and storing records until they are deleted. Generally, using this is enough.

But sometimes we don't need persistent database storage, then we can use the following two types of models:

- **Temporary models** inherit from the **models.TransientModel** class and are used for wizard-style user interactions. This type of data will be stored in the database, but only temporarily. A cleanup job will be run regularly to clear old data from these tables. For example, the **Settings** > **Translations** > **Import Translation** menu opens a dialog box that uses a temporary model to store user options and implement wizard logic. An example of a temporary model is discussed in [Chapter 8 Odoo 15 Development of Business Logic - Support for Business Processes](8.md).
- **Abstract models** inherit from the **models.AbstractModel** class, which does not contain data storage. Abstract models are used as reusable sets of functionality that work with other models that use Odoo's inherited functionality. For example, **mail.thread** is an abstract model in the **Discuss** application that adds messaging and following functionality to other models. Mixin classes that use abstract models and the aforementioned **mail.thread** example are discussed in [Chapter 4 Odoo 15 Development Module Inheritance](4.md).

### View existing models

Models and fields created by Python classes can be viewed through the user interface. Enable developer mode and access the menu **Settings** > **Technical** > **Database Structure** > **Models**, where all models in the database are available.

Clicking on a model in the list will open the details form, as shown below:

[![Figure 6.1: View the book model through the Technical menu](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/031a65d2fba04a8690e80b6db1793b92~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022052802431786.jpg)

**Figure 6.1**: Viewing the book model through the Technical menu

This is a great tool for viewing the structure of a model, because you can see here all the changes made by different modules. In the upper right corner of the form view, in the In Apps field, you can see a list of modules that affect it. In this example, the library.book model is affected by the library_app and library_member modules.

> **Tip:** As seen in [Chapter 1: Getting Started with Odoo 15 Using Developer Mode](1.md), the model form is editable. From here you can create and modify models, fields, and views. You can create prototypes here and then implement them in your plugin modules.

There are several more tabs in the lower area that contain additional information:

- **Fields** displays the fields of the model
- **Access Rights** displays the access control rules granted to different permission groups
- **Record Rules** displays the record rules used for the record filter
- **Notes** is the model definition documentation string
- **Views** displays the views of the model

We can view the external identifier or XML ID of a model through the **View Metadata** option in the developer menu. The external identifier of a model is automatically generated by the ORM and follows a simple set of rules: replace the period in the model name with an underscore and prefix it with **model_**. For example, the external identifier generated for the **library.book** model, created by the **library_app** module, is **library_app.model_library_book**. These XML IDs are usually required for CSV files that define permission ACLs.

Now that you are familiar with the options for defining a model, the next step is to learn about the various field types and their configuration options.

## Create fields

The first step after creating a new model is to add fields. Odoo supports all the basic data types you can think of, such as text strings, integers, floating point types, Booleans, dates, times, and images or binary data.

Let's take a look at some of the field types in Odoo.

### Basic field types

We'll add several field types to our Book model.

Edit the **Book** class in the **library_app/models/library_book.py** file and replace the current field definition with the following:

```
class Book(models.Model):
    _name = "library.book"
    _description = "Book"
    # String fields
    name = fields.Char('Title', required=True)
    isbn = fields.Char('ISBN')
    book_type = fields.Selection(
        [('paper', 'Paperback'),
        ('hard', 'Hardcover'),
        ('electronic', 'Electronic'),
        ('other', 'Other')],
        'Type')
    notes = fields.Text('Internal Notes')
    desc = fields.Html('Description')

    # Numeric fields:
    copies = fields.Integer(default=1)
    avg_rating = fields.Float('Average Rating', (3,2))
    price = fields.Monetary('Price', 'currency_id')
    currency_id = fields.Many2one('res.currency') # price helper

    # Date and time fields
    date_published = fields.Date()
    last_borrow_date = fields.Datetime(
        'Last Borrowed On',
        default=lambda self: fields.Datetime.now())

    # Other fields
    active = fields.Boolean('Active?', default=True)
    image = fields.Binary('Cover')

    # Relational Fields
    publisher_id = fields.Many2one('res.partner', string='Publisher')
    author_ids = fields.Many2many('res.partner', string='Authors')
```

These are examples of non-relational field types in Odoo, each of which can also accept some positional parameters. Next we will explain all of these types and their options.

> **Tips:**
>
> There are two types of arguments in Python: positional arguments and keyword arguments.
>
> **Positional parameters** must be used in the order specified. For example, **f(x, y)** should be called as **f(1, 2)**.
>
> **Keyword parameters** are passed by parameter name. As an example, you can use **f(x=1, y=2)** or even **f(1, y=2)** to pass parameters together.
>
> But please note that positional arguments must come before keyword arguments, **f(x=1, 2)** is not allowed. For more information about keyword arguments, see the Python [official documentation](https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments).

In general, the first positional argument is the field title, corresponding to the **string** keyword argument. The exception is the **Selection** field and all associated fields.

The **string** tag is used as the default text for the user interface label. If the **string** attribute is not passed, it will be automatically generated based on the field name by replacing underscores with spaces and capitalizing the first letter of the word. For example, the default label for **date_published** is **Date Published**.

For reference, here are all the non-relational field types and their positional parameters:

- **Char(string)** is a simple text field where the only positional parameter is the field label.
- **Text(string)** is a multi-line text field, the only positional parameter is the string field label.
- **Selection(selection, string)** is a drop-down list of choices. The option positional argument is a list of **[("value", "Description"),]** tuples. The first element of the tuple is the value stored in the database, the second element is the description displayed in the user interface. The list can be extended by other modules using the **selection_add** keyword argument.
- **Html(string)** is stored as a text field, but has special handling for displaying HTML content in the user interface. For security reasons, this field will be sanitized, but the sanitization behavior can be overridden using **sanitize=False**.
- **Integer(string)** is an integer number, only the field label string parameter is required.
- **Float(string, digits)** stores floating point numbers, the second optional parameter is the precision used. This is a **(n, d)** tuple, **n** is the total number of digits, **d** is the number of decimal places.
- **Monetary(string, currency_field)** is similar to floating point fields, but includes special handling for monetary values. The second parameter **currency_field** is the name of the currency field. The default setting is **currency_field="currency_id"**.
- **Date(string)** and **Datetime(string)** are date and datetime values. Only one label text is required as a positional parameter.
- **Boolean(string)** stores True or False values. Only one label text is required as the positional parameter.
- **Binary(string)** stores binary data including images. Only one string label position parameter is required.

These fields define the most commonly used basic parameters. Note that these are not mandatory, and Odoo will fill in appropriate default values ​​if they are not filled in.

> **Changes in Odoo 12**\
> **Date** and **Datetime** fields are now handled as Python date objects in the ORM. In previous versions, they were handled as text strings. Therefore, you need to explicitly convert them to Python date objects when performing operations, and then convert them back to text strings.

Text strings, including **Char**, **Text**, and **Html**, have some unique properties:

- **size** (only for **Char** fields) sets the maximum allowed size. Do not use this without special reasons, for example, it can be used for social security account numbers with a maximum allowed length.
- **translate=True** makes the field content translatable, with different values ​​for different languages.
- **trim** The default value is **True**, which automatically removes surrounding spaces in the web client. You can disable it by setting t**rim=false**.

> **Changes in Odoo 12**\
> The **trim** field attribute was introduced in Odoo 12. In previous versions, text fields preserved leading and trailing spaces.

In addition to these, there are also related fields that will be introduced later. This will be explained in the **Relationships between models** section later in this document.

However, we need to first learn some other knowledge about the basic field type properties in the next section.

### Common field properties

So far, we have learned the basic positional parameters of several basic field types. But there are some other properties.

The following keyword arguments are available for all field types:

- **string** is the default label of the field, used in the user interface. Except for **Selection** and related fields, it is the first positional parameter, so it is used as a keyword parameter in most cases. If not passed, it will be automatically generated from the field name.
- **default** sets the default value of the field. It can be a specific value (such as **default=True** in the **active** field), or a callable pointer, a named function pointer, or a **lambda** anonymous function.
- **help** provides the hint text displayed to the user when the mouse hovers over the field in the UI.
- **readonly=True** makes the field non-editable by default in the UI. Not enforced at the API level, code in model methods can still write to it, and view definitions can override it. Only set for the UI.
- **required=True** makes the field required by default in the user interface. This is done by adding a **NOT NULL** constraint to the field at the database level.
- **index=True** adds a database index to the field, making searches faster, but it will also partially occupy more disk space and slow down write operations.
- **copy=False** makes the field ignored when copying records using the ORM **copy()** method. Except for multi-relation fields, other field values ​​will be copied by default.
- **deprecated=True** marks the field as deprecated. The field can still be used normally, but a warning message will be written to the server log each time it is accessed.
- **groups** can restrict fields to be accessible and visible only to certain groups. The value is a comma-separated list of permission group XML IDs, such as **groups="base.group_user,base.group_system"**.
- **states** passes in the UI attribute dictionary mapping value that depends on the **state** field value. Available attributes are **readonly**, **required**, and **invisible**, for example **states={'done':[('readonly',True)]}**.

> **Tip**: Note that the states field is equivalent to the **attrs** attribute in the view. Also note that the view also supports the **states** attribute, but for a different purpose, passing in a comma-separated list of states to control when the element is visible.

The following is an example of a **name** field using all field attribute keyword arguments:

```
    name = fields.Char(
        "Title",
        default=None,
        help="Book cover title.",
        readonly=False,
        required=True,
        index=True,
        copy=False,
        deprecated=True,
        groups="",
        states={},
    )
```

Previous Odoo versions supported the **oldname="field"** attribute, which was used to rename fields in the new version. The data of the old field was automatically copied to the new field during the module upgrade process.

> **Changes in Odoo 13**
>
> Removed **oldname** field attribute, no longer available. Use migration script instead.

The above are common field properties that can be used for all field types. Next we will learn how to set default values ​​for fields.

### Setting Default Values

As mentioned before, the default attribute can take a fixed value, or reference a function to dynamically compute a default value.

For simple calculations, you can use lambda functions to avoid creating overly heavy named functions or methods. The following is a common example that calculates the default value of the current date and time:

```
    last_borrow_date = fields.Datetime(
        'Last Borrowed On',
        default=lambda self: fields.Datetime.now(),
    )
```

The value of **default** can also be a function reference. It can be a name reference or a function name string.

The following example uses a name reference to the _default_last_borrow_date function method:

Or the name string of the function to be defined:

```
    def _default_last_borrow_date(self):
        return fields.Datetime.now()
    last_borrow_date = fields.Datetime(
        'Last Borrowed On',
        default=_default_last_borrow_date,
    )
```

The following example does the same thing but uses a function name string:

```
    last_borrow_date = fields.Datetime(
        'Last Borrowed On',
        default="_default_last_borrow_date",
    )
    def _default_last_borrow_date(self):
        return fields.Datetime.now()
```

In the latter approach, the resolution of the function name is deferred until runtime, rather than when the Python file is loaded. Thus, in the second example, we can refer to the declaration later in the code, whereas in the first example, the function must be declared before use.

However, the general code standard is to define the default value function before the field definition. In addition, using the function name reference in the first example has an advantage. If static code analysis is supported, the code editor can detect type errors.

### Automatic field names

Some of the field names are special, either because they are ORM reserved words for special purposes, or because built-in functionality uses some default field names.

The **id** field is reserved for use as an auto-incrementing number to identify each record and as a database primary key, which is automatically added to each model.

The following fields will be automatically created in the new model as long as **_log_access=False** is not set in the model:

- **create_uid** is the user who created the record
- **create_date** is the date and time the record was created
- **write_uid** is the user who last modified the record
- **write_date** is the date and time the record was last modified

These field information for each record can be viewed through **View Metadata** under the developer menu.

The above mentioned field names have special meanings in the Odoo framework. In addition to them, there are some field names that are used as default fields for some Odoo functions. They will be explained in the next section.

### Reserved field names

Some built-in API functions require some specified field names by default. These are reserved field names and should be avoided from misuse.

These reserved fields are as follows:

- **name** or **x_name** of **Char** type: used as the display name of the record by default. Other fields can also use the **_rec_name** model attribute to set the display name. It can also be used for non-character field types, which will force the data to be converted to text.
- Boolean **active** and **x_active**: Allows us to turn off records, making them invisible. Records with **active=False** are automatically excluded from queries unless **{'active_test': False}** is added to the environment context. It can be used for record archiving or soft delete.
- **state** of **Selection** type: represents the basic state of the record lifecycle. It allows to dynamically set to **readonly**, **required** or **invisible** using **states** field attribute, for example **states={'draft': [('readonly', False)]}** .
- **parent_id** for many-to-one fields: used to define tree hierarchies, enabling **child_of** and **parent_of** operators in domain expressions. The field used as **parent_id** can be set to another field using the **_parent_name** model attribute.
- **parent_path** of type **Char**: used to optimize the use of **child_of** and **parent_of** operators in domain expressions. For normal operation, use **add index=True** to use the database index. We will discuss hierarchical associations in the **Hierarchical Associations** section later in this chapter.
- **company_id** of **Many2one** type: used to identify the company to which the record belongs. Leaving it blank means that the record is shared among various companies. Internal check of company data consistency is performed via **_check_company** function.

> **Changes in Odoo 14**
>
> **x_active** is now reorganized to be consistent with the **active** field. It is referenced to better support customization in developer mode or **Odoo Studio** applications.

So far we have discussed non-relational fields. However, a large part of the application data structure is to describe the relationship between entities. Let's learn about it together.

## Model Relationships

Medium to large business applications require associations between different entities involved. To achieve this, you need to use association fields.

Let's take a look at our book application. The book model has the following associations:

- Each book has one publisher, and each publisher has multiple books. From the book's perspective, this is a many-to-one association. This is achieved by having an integer field in the database that stores the ID of the associated publisher record, and putting a database foreign key to enforce the correctness of the reference.
- On the other hand, from the publisher's perspective, it is a one-to-many association, that is, a publisher can publish multiple books. Although this is also an Odoo field type, its database level relies on a many-to-one association. We know the associated publisher by querying the book and filtering out the publisher ID.
- Each book can have multiple authors, and each author can write multiple books. This is a many-to-many relationship. The reverse is also a many-to-many relationship. In a relational database, many-to-many relationships are implemented using an auxiliary table. Odoo handles this automatically, but we can also control it with technology if we want.

In the following subsections we will discuss each of these relationships.

A specific use case is hierarchical associations, where records in one model are associated with other records in the same model. We will introduce a book classification model to illustrate this situation.

Finally, the Odoo framework also supports flexible associations, that is, a field can be associated with multiple models, which is called a reference field.

### Many-to-one association

A many-to-one association is a reference to a record in another model. For example, in the book model, publisher_id represents the book publisher and is a reference to the partner record.

In case you've forgotten, here's the publisher field defined using purely positional parameters:

```
    publisher_id = fields.Many2one(
        'res.partner', 'Publisher')
```

The above many-to-one field definition uses positional parameters:

- The first positional parameter is the associated model, corresponding to the **comodel** keyword parameter, and the value in this case is **res.partner**.
- The second positional parameter is the field label, corresponding to the **string** keyword parameter. But it is different from other associated fields, so it is recommended to always use the **string** keyword parameter.

A many-to-one model field creates a field in the database table with a foreign key pointing to the related table, where the database ID of the related record is.

Keyword arguments are used instead of or in addition to positional arguments. The following keyword arguments are supported for many-to-one fields:

- **ondelete** defines the action to be performed when the associated record is deleted. The following actions can be used

    - **set null** (default value): The associated field will be set to a null value when it is deleted
    - **restricted**: Throws an error to prevent deletion
    - **cascade**: Delete the current record when the associated record is deleted

- **context** is a data dictionary that can pass information to web clients when browsing associations, such as setting default values. [Chapter 8 Odoo 15 Development of Business Logic - Business Process Support](8.md) will give a detailed explanation.

- **domain** is a domain expression: use a list of tuples to filter records as options for related records, which will be explained in detail in [Chapter 8 Business Logic of Odoo 15 Development - Support for Business Processes](8.md).

- **auto_join=True** allows the ORM to use SQL joins when searching using this association. Access rights rules will be skipped when used, and users can access association records that are not allowed by access rights rules, but SQL queries will be faster.

- **delegate=True** creates a proxy inheritance for the associated record. **required=True** and **ondelete='cascade'** must also be set when using it. For more information about proxy inheritance, see [Chapter 4 Odoo 15 Development Module Inheritance](4.md).

### One-to-many reverse association

A one-to-many relationship is the reverse of a many-to-one relationship. It lists the related model records that reference this record.

For example, in the Book model, the publisher_id field has a many-to-one relationship with the partner model. This means that the partner model can have a one-to-many inverse relationship with the Book model, listing the books published by each publisher.

Before creating a one-to-many relationship, you should create a many-to-one relationship in its associated model. To do this, add the following code to the **library_app/models/res_partner.py** file:

```
from odoo import fields, models

class Partner(models.Model):
    _inherit = 'res.partner'
    published_book_ids = fields.One2many(
        'library.book', # related model
        'publisher_id', # fields for "this" on related model
        string = 'Published Books')
```

We added a new file to our module, so don’t forget to import it in library_app/models/__init__.py:

```
from . import library_book
from . import res_partner
```

One2many fields accept three positional parameters:

- Associated model, corresponding to the **comodel_name** keyword parameter
- The model field that references the record, corresponding to the **inverse_name** keyword parameter
- Field label, corresponding to the **string** keyword parameter

Other available keyword arguments are the same as for many-to-one fields: **context**, **domain**, ****auto_join****, and **ondelete** (here it applies to the many side of the association).

### Many-to-many association

Use a many-to-many association when there is a to-many association on both ends. Let's take our book application as an example. There is a many-to-many association between books and authors: a book can have multiple authors, and an author can have multiple books.

The library.book model on the book side has the following definition:

```
class Book(models.Model):
    _name = 'library.book'
    author_ids = fields.Many2many(
        'res.partner',
         string='Authors')
```

On the author side, we can also add a reverse association for res.partner:

```
class Partner(models.Model):
    _inherit = 'res.partner'
    book_ids = fields.Many2many(
        'library.book',
        string = 'Authored Books')
```

The minimal signature of **Many2many** includes a positional parameter for the associated model (the **comodel_name** keyword parameter). It is recommended to use the **string** parameter to add field labels.

At the database level, many-to-many relationships do not add any fields to existing tables. Instead, a relationship table is automatically created to store the relationship between records. This special table has only two ID fields, which are foreign keys of the two relationship tables.

The default association table name is composed of two table names with an underscore in the middle and **_rel** at the end. In this example, the book and author association table name should be **library_book_res_partner_rel**.

Sometimes we may need to override this automatically generated default value. One case is that the name of the associated model is too long, causing the length of the automatically generated associated table name to exceed the 63-character limit of the PostgreSQL database. In this case, you need to manually select an associated table name that meets the character limit.

Another situation is that we need to establish a second many-to-many relationship between the same models. In this case, we also need to manually provide a relationship table name to avoid conflict with the existing first table name.

There are two ways to override the associated table name: positional or keyword arguments.

An example of a positional parameter defined via a field is:

```
# Book <-> Authors association (using positional parameters)
author_ids = fields.Many2many(
    'res.partner', # associated model (final payment)
    'library_book_res_partner_rel', # the name of the association table to be used
    'a_id', # Fields in the associated table of this record
    'p_id', # associated record associated table field
    'Authors') # string label text
```

For more readability, keyword arguments can also be used:

```
# Book <-> Authors association (using keyword arguments)
author_ids = fields.Many2many(
    comodel_name='res.partner', # Associated model (required)
    relation='library_book_res_partner_rel', # association table name
    column1='a_id', # This record is associated with the table field
    column2='p_id', # Associated record associated table field
    string='Authors') # string label text
```

The following are the parameters used here:

- **comodel_name** is the name of the comodel.
- **relation** is the name of the table that supports the relational data.
- **column1** is the name of the field pointing to the model record.
- **column2** is the name of the field in the related model record.
- **string** is the field label in the UI.

Similar to one-to-many relation fields, many-to-many relation fields can also use keyword parameters such as **context**, **domain**, and **auto_join**.

> **Tip**: In the abstract model, do not use **column1** and **column2** attributes for many-to-many fields. There is a limitation on abstract models in ORM design. If the associated table column name is specified, it can no longer be inherited normally.

Parent-child relationships are a special case that deserves further study. We'll do that in the next section.

### Hierarchical association

The parent-child tree association is represented by the many-to-one association in the same model, where each record points to its parent. The reverse one-to-many association represents the direct children of the record.

Odoo has improved support for these hierarchical data structures through the **child_of** and **parent_of** operators in domain expressions. These operators can be used as long as the models have a **parent_id** field (or **_parent_name** in a valid model definition, setting an alternative field name).

Hierarchical tree queries can be accelerated by setting the **_parent_store=True** model attribute and adding the **parent_path** auxiliary field. This auxiliary field stores the hierarchical tree structure information used to speed up queries.

> **Changes in Odoo 12**\
> The **parent_path** auxiliary field was introduced in Odoo 12. Previous versions used **parent_left** and **parent_right** integer fields to achieve the same functionality, but these fields were deprecated in Odoo 12.

To demonstrate the hierarchical structure, we will add a category tree to the book application to categorize books.

Add the following code to the **library_app/models/library_book_category.py** file:

```
from odoo import api, fields, models

class BookCategory(models.Model):
    _name = 'library.book.category'
    _description = 'Book Category'
    _parent_store = True

    name = fields.Char(translate=True, required=True)
    Hierarchy fields
    parent_id = fields.Many2one(
        'library.book.category',
        'Parent Category',
        ondelete='restrict')
    parent_path = fields.Char(index=True)
    # Optional but good to have:
    child_ids = fields.One2many(
        'library.book.category',
        'parent_id',
        'Subcategories')
```

Here we define a basic model that contains a parent_id field pointing to the parent record.

For faster tree-level searches, a _parent_store=True model attribute has been added. To use this attribute, you must also add a parent_path field and index it. The field name referring to the parent should be parent_id, but other field names can be used if the optional _parent_name model attribute is declared.

It is very convenient to add a field to list the immediate children. This is the one-to-many reverse association in the code above.

And don’t forget to add a reference to the above code in the `library_app/models/__init__.py` file:

```
from . import library_book
from . import res_partner
from .import library_book_category
```

Note that these additional operations take up storage and have execution time consumption, so they are suitable for scenarios with more reads and less writes, such as the classification tree in this example. They are only necessary when optimizing deep levels with multiple nodes, and may be misused in small or shallow levels.

### Flex joins using reference fields

Ordinary association fields can only point to a fixed association model, but the **Reference** field type is not subject to this limitation. It supports flexible associations, so the same field can point to multiple target models.

As an example, we add a reference field to the book category model to represent the featured book or author. Therefore, this field can reference a book or partne record:

```
     highlighted_id = fields.Reference(
        [('library.book', 'Book'), ('res.partner', 'Author')],
        'Category Highlight'
    )
```

This field definition is similar to the **Selection** field, but here the contents of the selection list are the model used for this field. In the user interface, the user first selects the model in the list and then selects a specific record in the model.

Reference fields can be stored in the database as character fields, containing the **<model>, <id>** string.

> **Changes in Odoo 12**\
> In previous Odoo versions, the models available in reference fields were configured in the menu Settings > Technical > Database Structure. These configurations were made available in reference fields by adding the odoo.addons.res.res_request.referenceable_models function to the model selection list. This configuration has been removed in Odoo 12.

So we have learned about the types of fields supported by Odoo. Fields can not only store user-added data, but also display calculated values. This feature will be discussed in the next section.

## Calculated fields

In addition to reading the values ​​stored in the database, field values ​​can also be automatically calculated by functions. The declaration of a calculated field is similar to that of a normal field, but there is an additional **compute** parameter to define the function used for calculation.

Calculated fields contain some business logic. Therefore, to fully use this function, you should also be familiar with the knowledge explained in [Chapter 8 Odoo 15 Development of Business Logic - Business Process Support](8.md). Here we will explain the usage of calculated fields, but the business logic will be kept as simple as possible.

Our example adds a calculated field to the **Books** model to display the publisher's country. This will display the country in the form view.

The code to find this value is simple: If book represents a book record, the publisher's country can be obtained using dot notation book.publisher_id.country_id.

Edit the book model in the **library_app/models/library_book.py** file. The code is as follows:

```
    publisher_country_id = fields.Many2one(
        'res.country', string='Publisher Country',
        compute='_compute_publisher_country'
    )

    @api.depends('publisher_id.country_id')
    def _compute_publisher_country(self):
        for book in self:
            book.publisher_country_id = book.publisher_id.country_id
```

First, the code above adds a **publisher_country_id** field and a computed property with a **_compute_publisher_country** method that calculates its value.

Methods are passed to fields as string arguments, but you can also pass a callable reference (the method identifier, without quotes). In this case, make sure the method is defined before the field in the Python file.

The coding standard for calculation method names is to add the **_compute_** prefix before the calculation field name.

The _compute_publisher_country method receives the self recordset to perform calculations on, and should set the calculated field values ​​for all of these records. It is necessary to iterate over the self recordset to set all of them.

The calculated value is set via a normal assignment (write) operation. The calculation in this case is quite simple: it is assigned with the value of the current book's publisher_id.country_id.

> **Tips:** The same calculation method can be used to calculate two or more fields. In this case, the method is applied to the **compute** attribute of the calculated field, and the calculation method should assign values ​​to all these fields.

A calculation method must assign values ​​to one or more fields. If the calculation method has if conditional branches, make sure that the calculated fields are assigned values ​​in each branch. Otherwise, an error will be reported in the branch that does not have a value assigned.

> **Changes in ODOO 13**
>
> Odoo 13 introduces calculated writable fields, which are intended to replace the **onchange** mechanism in the future. The calculated writable field has a calculation logic that is triggered when the dependency changes, and also allows users to set its value directly. This mechanism will be explained together with **onchange** in [Chapter 8 Odoo 15 Development of Business Logic - Business Process Support](8.md).

The **@api.depends** decorator is required to specify the fields that the calculation depends on. The ORM uses this to know when to trigger the calculation to update the stored or cached value. It accepts one or more field name parameters and can use dot notation to track field associations. In this example, the **publisher_country_id** field should be recalculated when **publisher_id.country_id** changes.

> Warning:
>
> Forgetting to add the **@api.depends** decorator to a calculated field or not adding all the dependent fields used by the calculation will cause the calculated field to not be recalculated as planned. This kind of bug is hard to find.

You can see the effect by adding the **publisher_country_id** field to the book form view, located in the **library_app/views/library_book.xml** file. When viewing it in the web page, make sure that the record you are viewing has the publisher with a country selected.

[![Book model form view](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f8d3ed3aec1412a8d6ee608b9d15235~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022052823360635.jpg)

### Searching and writing calculated fields

The calculated field we just created is readable but not searchable or writable. By default, calculated fields are calculated on the fly and the value is not stored in the database. This is why it cannot be searched like a normal field.

One way to overcome this limitation is to store the computed value in the database by adding the store = True attribute. It will be recomputed when any of the dependencies change. Because the value is stored, it can be searched like a normal field, without the need for a search function.

Calculated fields also support searching and writing without storage. This can be achieved by implementing special methods together with the calculation method:

- **search** method to implement search logic
- **inverse** method to implement write logic

Using these methods, the declaration of the calculated field can be modified as follows:

```
    publisher_country_id = fields.Many2one(
        'res.country', string='Publisher Country',
        compute='_compute_publisher_country'，
        inverse='_inverse_publisher_country',
        search='_search_publisher_country',
    )
```

Writing to a calculation field is the inverse logic of the calculation. Therefore, the method that handles the writing operation is called **inverse**.

In this example, setting the value of **publisher_country_id** will change the publisher's country.

Note that this will also change the value seen in all books from the same publisher. Normal permissions apply to these write operations, so they will only succeed if the current user also has write permissions on the partner model.

The implementation of the inverse method sets the computed field with the value, performing the actual write operations needed to make the changes persistent:

```
    def _inverse_publisher_country(self):
        for book in self:
            book.publisher_id.country_id = book.publisher_country_id
```

The original value operation copies the value of **book.publisher_id.country_id** to the **book.publisher_country_id** field. The reverse operation is shown in the code above, which performs the reverse operation. It reads the value set by **book.publisher_country_id** and writes it to the **book.publisher_id.country_id** field.

To enable search operations for a calculated field, you need to implement the **search** method. The **search** method intercepts the domain expression running on the calculated field and replaces it with an alternative domain expression that uses only ordinary stored fields.

In the example of **publisher_country_id**, the actual search is to operate on the **country_id** field of the corresponding record of the associated **publisher_id**. The translation method is as follows:

```
    def _search_publisher_country(self, opearator, value):
        return [('publisher_id.country_id', operator, value)]
```

When performing a search on a model, the domain expression tuple is the argument, providing details of the operator and the value used in the domain expression.

The **search** method is triggered when the calculated field is present in the condition of the domain expression. It receives the operator and value required for the search, and then translates it into raw search elements and adds it to the alternative search or expression. The **country_id** field is stored in the associated partner model, so our search implementation only needs to modify the original search expression to use the **publisher_id.country_id** field.

The domain expressions will be explained in detail in [Chapter 8 Business Logic of Odoo 15 Development - Business Process Support](8.md).

### Relational fields

The calculated fields we implemented in the previous section simply copy the value from the related record to the model's own field. It is usually used to display the fields of related records in a form. The Odoo framework provides a shorthand for this: the related field function.

Relational fields make fields from the related model available in the current model, accessible via dot notation call chaining. This allows access to relational fields in places where dot notation would not otherwise be useful, such as UI form views.

To create a related field, you need to declare a field of the desired type and use the **related** attribute to access the target related field by following the dot notation field chain.

The associated field can be used to achieve the same effect as the publisher_country_id calculated field described above.

The implementation using the associated fields is as follows:

```
    publisher_country_id = fields.Many2one(
        'res.country', string='Publisher Country',
        related='publisher_id.country_id',
    )
```

Essentially, relational fields are just computed fields that are quick implementations of the **search** and **inverse** methods. This means that they can be searched and written to directly.

By default, the associated field is read-only, so reverse write operations are not available. You can enable write operations by setting the **readonly=False** field property.

> **Changes in Odoo 12**\
> In previous Odoo versions, relational fields were writable by default, but this default has proven to be dangerous because it could modify configuration or master data without permission. Therefore, starting with Odoo 12, relational fields are read-only by default: **readonly=True**.

It is worth mentioning that the associated fields can also use **store=True** to store the values ​​in the database like other calculated fields.

This completes our study of the functionalities supported by Odoo fields, including calculated fields. Another important element of data structures is constraints, which enforce data quality and completeness. We will discuss this in the next section.

## Model constraints

Applications usually need to ensure data integrity and perform some verification to ensure that the data is complete and correct.

The PostgreSQL database manager supports a lot of useful validations: like avoiding duplicates, or checking that a value meets some simple conditions. Odoo models can take advantage of the PostgreSQL constraints feature.

Some checks require more complex logic that is best implemented using Python code. For these cases, we can use specific model methods to implement Python constraint logic.

Let’s learn both methods together.

### SQL model constraints

SQL constraints are added to the table definition and are enforced directly by PostgreSQL. They are defined using the _sql_constraints class attribute.

This is a list of tuples, and each tuple has the format **(name, sql, message)**:

- **name** is the constraint identifier name
- **sql** is the PostgreSQL syntax for the constraint
- **message** is the error message displayed to the user when the constraint validation fails

The most commonly used SQL constraints are used to prevent duplicate data, and the CHECK constraints are used to test data using SQL expressions.

For example, let's add two constraints to the **Book** model:

- Make sure there are no duplicate books with the same title and publication date.
- Make sure the publication date is not in the future.

Edit the **library_app/models/library_book.py** file and add the following code to implement these two constraints. Usually it is placed after the code for field declaration:

```Python
    _sql_constraints = [
        ('library_book_name_date_uq', # Constraint unique identifier
        'UNIQUE (name, date_published)', # Constraint SQL syntax
        'Book title and publication date must be unique'), # Message
        ('library_book_check_date',
        'CHECK (date_published <= current_date)',
        'Publication date must not be in the future.'),
    ]
```

For more information about PostgreSQL constraint syntax, see the [official documentation](https://www.postgresql.org/docs/current/ddl-constraints.html).

### Python model constraints

Python constraints can use custom code to perform validation. The validation method should add the @api.constrains decorator and contain a list of fields to be checked. Modification of any of the fields will trigger validation, and an exception will be thrown if the conditions are not met, usually reporting **ValidationError**.

For the book application, an obvious example is to prevent incorrect ISBN numbers from being inserted. We have written the ISBN validation logic in the **_check_isbn()** method. You can use it in a model constraint to prevent incorrect data from being saved.

Edit the **library_app/models/library_book.py** file and add the import statement at the top of the file:

```
from odoo.exceptions import ValidationError
```

Next, add the following code to the **Book** class in the same file

```
    @api.constrains('isbn')
    def _constrain_isbn_valid(self):
        for book in self:
            if book.isbn and not book._check_isbn():
                raise ValidationError('%s is an invalid ISBN' % book.isbn)
```

Python constraints are usually placed before the code for field declarations.

## Overview of Odoo's base model

In the previous articles, we created new models, such as the Book model, but also used existing models, such as the Partner model that comes with the Odoo base module. Let's introduce these built-in models.

There is a base plugin module in the Odoo framework core. It provides the basic functions required by Odoo applications. It is located in the ./odoo/addons/base subdirectory of the Odoo code base.

Provides standard add-on modules for official applications and features in Odoo, relying on and building on the **base** module. Standard add-ons are located in the **./addons** subdirectory of the Odoo codebase.

The base module contains two types of models:

- Information Repository, **ir.*** model
- Resources, **res.*** model

The information warehouse is used to store the basic data required by the Odoo framework, such as menus, views, models, actions, etc. The data under the **Technical** menu is usually stored in the information warehouse model.

Examples include:

- **ir.actions.act_window** for window actions
- **ir.config_parameter** is used for global configuration items
- **ir.ui.menu** for menu items
- **ir.ui.view** for views
- **ir.model** for the model
- **ir.model.fields** for model fields
- **ir.model.data** for XML ID

Resource models store the basic master data used by all modules.

Here are some important resource models:

- **res.partner** is used for business partners, such as customers, suppliers and addresses
- **res.company** for company data
- **res.countr**y for country
- **res.country.state** for states or regions within a country
- **res.currency** for currency
- **res.groups** is used to apply permission groups
- **res.users** for application users

These should help you understand where these models are coming from when you encounter them in the future.

## Summarize

At the end of this chapter, we are familiar with various model types, such as temporary models and abstract models, and their usefulness for user interface wizards and mixin middleware. Other model features are Python and SQL constraints, which can be used to prevent data entry errors.

We also learned about the available field types and all the properties they support so that business data can be represented in the most precise way possible. We also learned about relationship fields and how to use them to create the relationships between different entities required by our application.

Then, we learned that models usually inherit from the **models.Model** class, but you can also use **models.Abstract** to create reusable mixins and **models.Transient** to create wizards or advanced user interaction dialogs. We learned about common model attributes, such as **_order** for sorting and **_rec_name** to specify the default field used when displaying records.

The fields in a model define all the data to be stored. We also learned about non-relational field types and the properties they support. We also learned about some relational field types: many-to-one, one-to-many, and many-to-many, as well as how to define relationships between models, including hierarchical parent-child relationships.

Most fields store user input in the database, but fields can also automatically calculate values ​​through Python code. We learned how to implement calculated fields, as well as some advanced uses, such as making calculated fields writable and searchable.

Another part of model definition is constraints, enforcing data consistency and performing validation. This can be done through PostgreSQL or Python code.

Once we have created the data model, we should provide it with some default and demo data. In the next chapter we will learn how to import, export and load data in the system using data files.

## Further reading

[Official documentation](https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html) about models.