# Chapter 4 Odoo 15 Development Module Inheritance

One of the great strengths of Odoo is the ability to add functionality without directly modifying the code of the module being extended. This is possible thanks to the inheritance of functionality that is independent of the code component itself. Extensions to modules are made possible through inheritance, in the form of layers of modifications to existing objects. These modifications can happen at every level, including the model, view, and business logic. Instead of modifying the original module directly, we create a new module that adds a layer on top of the existing one with the modifications we want to make.

The previous chapter explained how to create an application from scratch. In this chapter, we will learn how to create a module that inherits from an existing application or module and use the original core or community functions.

To this end, we will explain the following:

- Learning Project-Extended Book Application
- Add new fields to existing models
- Extend models using classic in-place inheritance
- Other model inheritance mechanisms
- View and data inheritance
- Web page inheritance

After studying this chapter, you will be able to create inherited modules for existing Odoo applications. You can modify any component of the application: models, views, business logic code, web controllers, and web templates.

## Development Preparation

This article requires that the Odoo server can be started through the command line.

The code will be modified based on [Chapter 3 Odoo 15 Development: Creating the First Odoo Application](3.md). Through the study of this chapter, we have added the code to the plugin path and installed the library_app module in the database.

This chapter adds a new **library_member** plugin module to the project. For the corresponding code, please see the **ch04** directory of the [GitHub repository](https://github.com/iTranslateX/odoo-essentials/tree/main/source-code/).

## Learning Project - Extending Library Application

In [Chapter 3 Odoo 15 Development: Creating the First Odoo Application](3.md) we created an initial module for the library application, which can be used to view the book list. Now we want to extend the library application to add library members and allow them to borrow books. This requires creating an extension module library_member.

We want to provide the following functions:

- Books can be controlled whether they can be borrowed. This information should be displayed in the book form and the catalog page of the website.
- Some library membership data, including library membership card number and personal data such as name, address and email.
- Member messaging and social features should be provided on the borrowing form, including a planning event widget, to make collaboration more streamlined.

Later we will introduce a feature that allows members to borrow books from the library, but this is beyond the scope of this discussion. It will be gradually developed in the next few chapters.

### Books

The following is a summary of the technical changes that will be made to the book:

- Added an **Is Available?** field. Currently managed manually, will be automated in the future.
- Expanded ISBN validation logic to also support 10-digit ISBNs.
- Extend the book catalog page to identify unavailable books and allow users to filter available books

### Members

The following is a summary of the technical changes that will be made to the library membership:

- Add a new model to store name, card number and contact information such as email and address
- Add social discussion and event planning features

First, create a **library_member** directory in the same directory as **library_app** as an extension module, and add two files to it, an empty `__init__.py` file and a `__manifest__.py` file with the following content:

```
{
    'name': 'Library Members',
    'description': 'Manage people who will be able to borrow books.',
    'author': 'Alan Hou',
    'depends': ['library_app'],
    'application': False,
}
```

Now we can start developing the functionality. The first task is a common and simple requirement: adding a new field to an existing model. This is a good opportunity to introduce the Odoo inheritance mechanism.

## Adding fields to existing models

The first step is to add the **is_available** Boolean field to the Book model. Currently it is just a simple editable field, but later we will turn it into an automatic value based on the borrowed and returned books.

To inherit an existing model, you need to add a **_inherit** attribute to the Python class to indicate the model you want to inherit. The new class inherits all the functionality of the parent Odoo model, and you only need to declare the modifications you want to make. You can think of this type of inheritance as a reference to an existing model with some modifications inserted.

### Inserting new fields into a model via inheritance

Inherited models are declared through Python classes and Odoo's own inheritance mechanism using the _inherit class attribute. The _inherit attribute identifies the model being inherited. The declared call grabs all the functionality of the parent Odoo model, declaring only the parts that need to be modified.

The coding guidelines recommend creating a Python file for each model, so we add the library_member/models/library_book.py file to inherit the original model. First create the `__init__.py` file to import the file:

1. Add the `library_member/__init__.py` file to import the models subfolder

```
from . import models
```

2. Add the `library_member/models/__init__.py` file and import the files in the **models** subfolder:

```
from . import library_book
```

3. Create the `library_member/models/library_book.py` file to inherit the library.book model:

```
from odoo import fields, models

class Book(models.Model):
    _inherit = 'library.book'
    is_available = fields.Boolean('Is Available?')
```

Here we use the _inherit class attribute to declare the inherited model. Note that we do not use any other class attributes, not even _name. You do not need to use these attributes unless you want to make changes.

> **Tip:** **_name** is the model identifier. What happens if you modify it? Actually, you can modify it. In this case, it will create a copy of the inherited model as a new model. This is called prototype inheritance, which will be discussed in the section **Copying models through prototypes** later in this article.

Think of it as referencing a model definition in the central repository and then modifying it. Modifications include adding fields, modifying existing fields, modifying model class attributes, or adding methods with new business logic.

To add a new model field to the database table, you must first install the plug-in module. If everything goes well, you can view the new field in the **library.book** model through the **Technical** > **Database Structure** > **Models** menu.

[![Add the field is_available through inheritance](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff92672481114741a9dc7662e7cd120f~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022051323592916.jpg)

### Add fields to the form view

Form, list and search views are defined using XML data structures. You need a way to modify the XML to inherit the view. That means locating the XML element and making the modification there.

The XML data record of the inherited view is similar to that of the ordinary view, with an additional **inherit_id** attribute to reference the inherited view.

Next we extend the book view and add the is_available field.

First, find the XML ID of the view to be inherited. Check it through the **Settings > Technical > User Interface > Views** menu. The XML ID of the book form is **library_app.view_form_book**.

Then we need to find the XML element where we want to insert the modification. We chose to add the **Is Available?** field after the **ISBN** field. Usually we locate the element by the **name** attribute. In this case, it is ` <field name="isbn" /> `.

We add an XML file, namely **views/book_view.xml** to inherit the **Partner** view, with the following content:

```
<odoo>
    <record id="view_form_book_extend" model="ir.ui.view">
        <field name="name">Book: add Is Available? field</field>
        <field name="model">library.book</field>
        <field name="inherit_id" ref="library_app.view_form_book" />
        <field name="arch" type="xml">
            <field name="isbn" position="after">
                <field name="is_available" />
            </field>
        </field>
    </record>
</odoo>
```

In the above code, we have highlighted the inheritance related elements. The inherit_id record field locates the inherited view through the ref attribute pointing to the external identifier of the view.

**arch** contains the elements used at the declared extension point, a ` <field> ` element with **name="isbn"** and **position="after"** to declare the position. Within the extension element, the **is_available** field is added using XML.

After creating the inheritance, the book form (add the view file in the declaration file and upgrade the plug-in) is as follows:

[![Figure 4.1: Book form after adding the Is Available? field](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f69ff338fe17434ba4702ab0152c0827~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022051400413128.jpg)

**Figure 4.1:** Book form after adding the Is Available? field

We have learned the basics of inheritance and added a new field to the model and view layers. Next, we will learn the model inheritance method we use, which is classic inheritance.

## Extending the model using classic in-place inheritance

Classic model inheritance can be thought of as an in-place extension. When a Python class with the _inherit attribute is declared, it gets a reference to the corresponding model definition and then extends it. The model definition is stored in the Odoo model repository and can be further modified.

Next, we will learn how to use classical inheritance in common inheritance use cases: modifying the properties of existing fields and extending Python methods to add or change business logic.

### Incrementally modify existing fields

When inheriting a model, you can make incremental changes to existing fields. That is, you only need to define the properties you want to modify or add.

We make two modifications to the Book model created in the **library_app** module:

- Add a reminder for the **isbn** field to indicate that both 10-digit and 13-digit ISBNs are supported, and this feature will be implemented later
- Add database index for **publisher_id** field to improve search efficiency

Edit the **library_member/models/library_book.py** file and add the following code to the **library.book** model:

```
class Book(models.Model):
...
    isbn = fields.Char(help="Use a valid ISBN-13 or ISBN-10.")
    publisher_id = fields.Many2one(index=True)
```

This will modify the specified attributes of the field; unspecified attributes will remain unchanged.

[![Add help text to ISBN field](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cc42fc0a0564595b47e2cfd3706e9ac~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022051401134894.jpg)

Upgrade the module, enter the book form, hover the mouse over the ISBN field, and you can see the added tooltip information. The effect of the **index=True** modification is not easy to find. You can view it in the field definition under the **View Fields** option in the Developer Tools menu or the **Settings > Technical > Database Structure > Models** menu.

[![Figure 4.2: Indexing is enabled for the publisher field](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ffab7c49b0f41338cdc3a9566eac882~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022051401114579.jpg)

**Figure 4.2:** Indexing is enabled for the publisher field

### Inherit Python methods to add functionality to business logic

Business logic written in Python methods can also be inherited. Odoo borrows Python's existing object inheritance mechanism for parent class behavior.

As a practical example, we will extend the validation logic of the book ISBN. In the book application, only modern 13-digit ISBNs can be validated, but older books may only have 10-digit ISBNs. We inherit the **_check_isbn()** method to complete the validation in this case.

Add the following code to the **library_member/models/library_book.py** file:

```
from odoo import api, fields, models

class Book(models.Model):
...

    def _check_isbn(self):
        self.ensure_one()
        isbn = self.isbn.replace('-', '')
        digits = [int(x) for x in isbn if x.isdigit()]
        if len(digits) == 10:
            ponderators = [1, 2, 3, 4, 5, 6, 7, 8, 9]
            total = sum(a * b for a, b in zip(digits[:9], ponderators))
            check = total % 11
            return digits[-1] == check
        else:
            return super()._check_isbn()
```

To inherit a method in an inherited class, we need to redefine the method with the same method name, in this case, it is **_check_isbn()**. This method uses super() to call the method implemented by the parent class. The corresponding code in this case is **super()._check_isbn()**.

In the method inheritance, we added our own logic before calling **super()** of the parent class. This method verifies whether the ISBN is 10 digits. If so, it executes the added verification for 10 digits ISBN. Otherwise, it enters the original 13 digit verification logic.

If you want to test or write test cases. Here is an example of a 10-digit ISBN: The original ISBN of "Lord of the Flies" by William Golding is 0-571-05686-5.

> **Changes in Odoo 11**
> In Odoo 11, the Python version used has changed from *2.7* to *3.5* or later. Python 3 has undergone a major revision and is not fully compatible with Python 2. In particular, the syntax of **super()** has been simplified in Python 3. In previous Odoo versions using Python 2, **super()** required two parameters: the class name and **self**; for example **super(Book, self)._check_isbn()**.

Classic inheritance is the most commonly used inheritance mechanism. But Odoo also provides other inheritance methods for other scenarios. Let's learn them together.

## Other model inheritance mechanisms

We have introduced classical inheritance, which can be seen as an extension of in-place modification. This is the most commonly used method, but the Odoo framework also supports several inheritance mechanisms for other scenarios.

They are proxy inheritance, type inheritance, and using mixin:

- **Proxy inheritance** embeds another model in the inherited model. For example, a **User** record embeds a **Partner** record, so the **User** record has all the fields of the **Partner** record, as well as the fields of the **User** record itself. Proxy inheritance uses the **_inherits** attribute.
- **Prototype inheritance** copies the functionality of the inherited model, creating a new model with its own tables and data. Prototype inheritance is not often used and is not implemented in Odoo's built-in plugin modules. Use **_inherit** to set the model to be copied, and the **_name** attribute is the identifier of the newly created model.
- A Mixin class is an abstract model that implements functionality that is widely reused in other models. It is a bit like a container that can be added to other models, but is not used on its own. For example, the mail.thread model is provided by the mail plugin model. It implements a chat window and send message functionality, and is used in multiple Odoo models, such as Partners and Sales Quotes. Mixin classes are constructed through Models.abstract instead of Models.model, and are used through _inherit.

The following sections will explain this in more depth.

### Using proxy to inherit embedded models

Use proxy inheritance to reuse data structures in the database without duplicating the data. It embeds the proxied model instance in the inherited model.

> **Note:** Strictly speaking from a technical point of view, proxy inheritance is not really object inheritance, but a kind of object combination, which delegates some functions of one object to another object, or provides some functions by another object.

Important points about proxy inheritance:

- Creating a new model record also creates and links the proxied model record.
- Proxy model fields that do not exist in the inherited model can be read and written, similar to associated computed fields.

For example, for the core User model, each record contains a Partner record, and therefore contains all the fields in Partner as well as some fields of the User itself.

In the book project, we are going to add a book membership model. Members have membership cards and use them to borrow books. The member master data should contain the card number, as well as some personal information such as email and address. The Partner model already contains contact and address information, so it is better to reuse it instead of creating duplicate data structures.

Follow the steps below to use proxy inheritance to add the Partner field to the book membership model:

1. You need to import the Python file that implements the process. Edit **library_member/model/__init__.py** and add the following highlighted code:


    ```
    from . import library_book
    from . import library_member
    ```

1. Then add a Python file describing the new library member model: **library_member/models/library_member.py**, which contains the following code:


    ```
    from odoo import fields, models

    class Member(models.Model):
        _name = 'library.member'
        _description = 'Library Member'
        card_number = fields.Char()
        partner_id = fields.Many2one(
            'res.partner',
            delegate=True,
            wavelet='cascade',
            required=True)
    ```

    Through proxy inheritance, **library.member** embeds the inherited model: **res.partner**, so when a new member record is created, an associated Partner will be automatically created and referenced through the partner_id field.

    Through the proxy mechanism, all fields of the nested model are automatically available as parent model fields. In this example, the Member model can use all fields in Partner, such as **name**, **address** and **email**, as well as Member's own unique fields, such as **card_number**. The underlying Partner fields are stored in the associated Partner record, without duplication of data structure.

    Proxy inheritance is only used at the data level, not at the logic level. You do not inherit any methods of the inherited model. However, you can still use the dot operator, also known as dot notation, to access object properties. For example, partner_id.open_parent() in the Member model runs the open_parent() method of the nested Partner record.

    There is an alternative syntax for proxy inheritance, using the **_inherits** model attribute. This comes from the old API before Odoo 8, but is still widely used. The book model code with the same effect as the above code is as follows:

    ```
    from odoo import fields, models

    class Member(models.Model):
        _name = "library.member"
        _description = "Library Member"
        _inherits = {"res.partner": "partner_id"}
        card_number = fields.Char()
        partner_id = fields.Many2one(
            "res.partner",
            ondelete="cascade",
            required=True)
    ```

    To add a new model, you need to complete a few more steps: add permission ACLs, menus, and some views.

1. Add permission ACL, create **library_member/security/ir.model.access.csv** file and add the following code:


    ```
    id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
    access_member_user,Member User Access,model_library_member,library_app.library_group_user,1,1,1,0
    access_member_manager,Member Manager Access,model_library_member,library_app.library_group_manager,1,1,1,1
    ```

1. Add a menu item, create the **library_member/views/library_menu.xml** file and add the following code:


    ```
    <odoo>
        <act_window id="action_library_member"
            name="Library Members"
            res_model="library.member"
            view_mode="tree,form" />
        <menuitem id="menu_library_member"
            action="action_library_member"
            parent="library_app.menu_library" />
    </odoo>
    ```

1. Add a view, create the **library_member/views/member_view.xml** file and add the following code:


    ```
    <odoo>
        <record id="view_form_member" model="ir.ui.view">
            <field name="name">Library Member Form View</field>
            <field name="model">library.member</field>
            <field name="arch" type="xml">
                <form>
                    <group>
                        <field name="name" />
                        <field name="email" />
                        <field name="card_number" />
                    </group>
                </form>
            </field>
        </record>
        <record id="view_tree_member" model="ir.ui.view">
            <field name="name">Library Member List View</field>
            <field name="model">library.member</field>
            <field name="arch" type="xml">
                <tree>
                    <field name="name" />
                    <field name="card_number" />
                </tree>
            </field>
        </record>
    </odoo>
    ```

1. Finally, edit the manifest file to declare these three new files:


    ```
        "data": [
            "security/ir.model.access.csv",
            "views/book_view.xml",
            "views/member_view.xml",
            "views/library_menu.xml"
        ],
    ```

If the code is written correctly, you can use the new book membership model after upgrading the module.

[![Book membership model form view](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c8cc39041a74677a8bff69715878e0e~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022051405180182.jpg)

### Using prototype inheritance to copy functions

Classic inheritance uses the _inherit property to extend a model. Because it does not modify the _name property, you can perform efficient in-place changes to the model.

If you use **_inherit** and modify the **_name** attribute at the same time, you will get a copy of the inherited model. At this time, the new model will gain functionality only for itself and will not be added to the parent model. The copy model is independent of the parent model and is not affected by changes to the parent model. It has its own data tables and data. The official documentation calls this inheritance **prototype inheritance**.

In actual development, using **_inherit** to copy models is not very useful. Generally, proxy inheritance is more preferred because data structures can be reused without copying.

When inheriting from multiple parent models, the value of **_inherit** is not a single name, but a list of model names.

This can be used to mix multiple models into one model. This way we can use the functionality of the same model multiple times. Abstract mixin classes make extensive use of this pattern. We discuss it in the next section.

### Use mixin class to reuse model functions

Assign the _inherit attribute to a list of model names that will inherit the functionality of those models. This is mostly done using mixin classes.

**mixin classes** are like containers for some functions that can be reused. They implement common functions and can be added to other models. They are generally not used directly alone. Therefore, mixin classes are abstract models based on **models.AbstractModel**, and do not have actual data tables like **models.Model**.

Odoo standard plugins provide some useful mixins. You can find them by searching for **models.AbstractModel** in the code. Worth mentioning, and probably the most commonly used, are the following two mixins, provided by the Discussion (Discuss: **mail** plugin model) application:

- **mail.thread** provides the message panel functionality (also known as chatter**) below or to the right of many document forms, as well as message and notification related logic.

- **mail.activity.mixin** provides activities functionality for defining and scheduling to-do tasks, and is also exposed through the chat discussion widget.


    > **Changes in Odoo 11**
    >
    > *activities* mixin is a feature introduced in Odoo 11 and is not available in earlier versions.

Chat windows and events are widely used features, and in the next section we will show you how to add them.

### Add message chat window and plan activities to the model

Let's add message chat and activity mixins to the book membership model. The steps are as follows:

1. Add the plugin model dependency that provides mixin, that is, **mail**.
1. Inherit the two mixin classes **mail.thread** and **mail.activity.mixin**
1. Add fields in the form view.

Let’s go through the above steps in detail:

1. Edit the `__manifest__.py` file to add dependency on the **mail** plugin:


    ```
    "depends": ["library_app", "mail"],
    ```

1. Edit the library_member/models/library_member.py file to inherit the mixin class and add the following highlighted code:


    ```
    class Member(models.Model):
        _name = 'library.member'
        _description = 'Library Member'
        _inherit = ["mail.thread", "mail.activity.mixin"]
    ```

    By adding this line of code, our model will include all the fields and methods of these mixins.

    > Tip: In this example, the mixins are added to the newly created models. If you want to add them to existing models created in other modules, the parent model should also appear in the inheritance list, such as: **_inherit = ["library.member", "mail.thread", "mail.activity.mixin"]** .

1. Finally, add the relevant fields in the book member form view. Edit the **library_member/views/member_view.xml** file and add the following highlighted code:


    ```
        <record id="view_form_member" model="ir.ui.view">
            <field name="name">Library Member Form View</field>
            <field name="model">library.member</field>
            <field name="arch" type="xml">
                <form>
                    <group>
                        <field name="name" />
                        <field name="email" />
                        <field name="card_number" />
                    </group>
                    <!-- mail mixin fields -->
                    <div class="oe_chatter">
                        <field name="message_follower_ids" widget="mail_followers"/>
                        <field name="activity_ids" widget="mail_activity"/>
                        <field name="message_ids" widget="mail_thread"/>
                    </div>
                </form>
            </field>
        </record>
    ```

As you can see, the **mail** module not only provides fields for followers, scheduled activities, and messages, but also provides specific web client widgets for them, which are all used here.

After upgrading the module, the book membership view should look like this:

[![Figure 4.3: Book membership form view](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/151efcfa36864d8d81f4ecf8aba3980a~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022051406114126.jpg)

**Figure 4.3:** Book membership form view

Note that the mixin itself does not make any changes to access permissions, including record rules. There are built-in record rules that limit the records that each user can access. For example, if you want a user to only view the records of people they follow, you must explicitly add this record rule.

The mail.thread model contains a field called message_partner_ids to show the followers of a partner. To implement a follower access rule, you need to add a record rule with a scope expression like [('message_partner_ids', 'in', [user.partner_id.id])]

So far, we have learned how to extend modules at the model and logic level. The next step is to learn about view inheritance to display model level modifications.

## View and Data Inheritance

Views and other data components can also be modified through module inheritance. In the case of views, this is usually done by adding functionality. The view presentation structure is defined in XML. For XML inheritance, we need to locate the node to be inherited and then declare the operation to be performed there, such as inserting an XML element.

Other data elements are represented by records written into the database. Inherited modules write on them to modify some values.

### View inheritance

Views are defined in XML and stored in the structure field **arch**. To inherit a view, we need to locate the node to be inherited and then declare the changes made, such as adding XML elements.

Odoo comes with a simplified markup that inherits XML, using the XML tag you want to match, such as ` <field> `, by matching one or more unique attributes, such as **name**. Then you must add the **position** attribute to declare the type of modification.

Going back to the example in this chapter where we added content after the isbn field, we could use the following code:

```
<field name="isbn" position="after">
    <!-- Add changes here-->
</field>
```

Any XML element and attribute except **string** attributes can be used to select nodes used by inheritance points. String attributes are translated into the user's language during view generation and therefore cannot be used as node selectors.

> **ℹ️** Before 9.0, string attributes (display label text) can also be used as inherited locators. After 9.0, this is no longer allowed. This limitation is mainly due to the language translation mechanism of these strings.

Use the **position** attribute to declare inherited operations. Multiple operations are allowed, as follows:

- **inside** (default): Add content inside the selected node, which should be a container like `<group>` or `<page>`

- **after**: Add content to the parent node after the selected node

- **before**: Add content to the parent node before the selected node

- **replace**: Replace the selected node. If empty content is used, the element will be deleted. Odoo 10 also allows the use of other tags to wrap elements, by using **$0** in the content to indicate the replaced element, such as ` <field name="name" position="replace"><h1>$0</h1></field> `.

- **attributes**: Modify the attribute values ​​of the matched elements. The content should contain one or more ` <attribute name="attr-name">value<attribute> ` elements. For example, `<attribute name="invisible">True</attribute>`. Without content, such as `<attribute name="invisible" />`, the attributes will be removed from the selected elements.


    > **Tip:** Although position="replace" can delete XML elements, you should avoid doing so. Doing so can break other plugin elements that rely on the deleted node as an extension point. An alternative is to keep the element and make it invisible.

### Migrate XML nodes to other places

In addition to the attributes operation, the above locators can be combined with child elements with **position="move"**. The effect is to move the child locator target node to the parent locator's target position.

> **Changes in Odoo 12**
> The position="move" sub-positioner is new in Odoo 12 and was not available in previous versions.

The following example moves **my_field** from its current position to after **target_field**.

```
<field name="target_field" position="after">
    <field name="my_field" position="move"/>
</field>
```

Other view types, such as list and search views, also have arch fields, which can be inherited in the same way as form views.

### Select inheritance points using XPath

Sometimes there may not be an attribute with a unique value to use as an XML node selector. This can happen when the selected element has no name attribute, such as the `<group>`, `<notebook>` or `<page>` view elements. Another case is when there are multiple elements with the same **name** attribute, such as in a kanban QWeb view where the same field may be included multiple times in the same XML template.

In these cases we need a more advanced way to locate the XML element to be expanded. A natural way to locate elements in XML is XPath expressions.

Taking the book form view defined in the previous chapter as an example, the XPath expression for locating the `<field name="isbn">` element is **//field[@name]='isbn'**. This expression finds the `<field>` element whose **name** attribute is equal to **isbn**.

The XPath inherited from the book form view in the previous section is:

```
<xpath expr="//field[@name='isbn']" position="after">
    <field name="is_available" />
</xpath>
```

For more information about XPath syntax, see the [Python official documentation](https://docs.python.org/3/library/xml.etree.elementtree.html#supported-xpath-syntax).

If the XPath expression matches multiple elements, only the first one will be selected as the extension target. So the expression should be as precise as possible, using unique attributes. The **name** attribute is the easiest to ensure that the exact element is found as the extension point. Therefore it is very important to add unique identifiers when creating view XML elements.

### Modify existing data

Ordinary data records can also be inherited. In practical applications, existing values ​​are usually overwritten. In this case, we only need to locate the record to be written, as well as the updated fields and values. There is no need to use XPath expressions because we are not modifying the XML **arch** structure like we do with views.

` <record id="x" model="y"> `The data loading element performs an insert or update operation on the y model: if record x does not exist, it is created, otherwise it is updated/overwritten.

Records in other modules are accessible via the `<module>.<identifier>` global identifier, so one module can update records created by other modules.

> **Tip:** The dot ( **.** ) is a reserved symbol used to separate module names and object identifiers. So do not use dots in identifier names, but use underscore ( **_** ) characters instead.

For example, we change the name of the **User** security group to **Librarian**. The corresponding modification is done on the record created in the **library_app** module, using the **library_app.library_group_user** identifier.

Add **library_member/security/library_security.xml** and add the following code:

```
<odoo>
    <!-- Modify the permission group name-->
    <record id="library_app.library_group_user" model="res.groups">
        <field name="name">Librarian</field>
    </record>
</odoo>
```

Here we use a <record> element and write only the name field. This can be considered as a write operation to this field.

> **Tip:** When using the ` <record> ` element, you can choose the fields to write to, but this is not the case with shorthand elements, such as ` <menuitem> ` and ` <act_window> `. They require all attributes to be provided, and missing any one will set the corresponding field to an empty value. However, you can use ` <record> ` to set values ​​for fields that were originally created using shorthand elements.

Add **security/library_security.xml** to the declaration file data. Then update the module to see the change of user group name.

[![Modify user group name](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf917b0f93ee42d29aadad5f8a7763fe~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/202205140725544.jpg)

Inheriting views allows us to make changes to the backend presentation layer. But we can also do the same with the frontend web page. We will explain this in the next section.

## Page inheritance

Extensibility is a key design choice of the Odoo framework, and Odoo web components can also be inherited. Therefore, Odoo web controllers and templates can be extended.

In the book application created in [Chapter 3 Odoo 15 Development: Creating the First Odoo Application](3.md), there is a book catalog page that can be improved.

We'll extend it to use the book availability added in the book membership module:

- Add support for query parameters on the controller side, access **/library/books?available=1** to filter out the books that can be borrowed
- On the template side, specify that books cannot be borrowed

Let's inherit the web controller first.

### Inheriting the web controller

The web controller processes web page requests and renders the page to return a response. It should focus on display logic and not business logic, which is handled in the model method.

Supporting parameters or URL routing belongs to the web page display part and is suitable for processing by web page controller.

The /library/books endpoint is extended here to support the query string parameter available=1, which is later used to filter the library catalog to show only books that are available for borrowing.

To extend an existing controller, you need to import the original object that created it, declare a Python class based on it, and then implement the class methods that contain the added logic.

Add the inherited controller code in the **library_member/controllers/main.py** file as follows:

```
from odoo import http
from odoo.addons.library_app.controllers.main import Books

class BookExtended(Books):
    @http.route()
    def list(self, **kwargs):
        response = super().list(**kwargs)
        if kwargs.get('available'):
            Book = http.request.env['library.book']
            books = Book.search([('is_available', '=', True)])
            response.qcontext['books'] = books
        return response
```

Add the controller code as follows:

1. Add the **library_member/controllers/main.py** file and make sure it contains the above code.

1. Add a **library_member/__init__.py** file to the controller subdirectory to make the newly added Python file importable in the module:


    ```
    from . import models
    from . import controllers
    ```

1. Add the following code in **library_member/controllers/__init__.py**:


    ```
    from . import main
    ```

1. After that, visit http://localhost:8069/library/books?available=1, and only the books with the **Is Available?** field checked should be displayed.

Let's review the controller extension code to understand its implementation principle.

The controller **Books** to be inherited was originally declared in the **controllers/main.py** file of the **library_app** module. Therefore, you need to import **odoo.addons.library_app.controllers.main** to reference this file.

This is different from models, where there is a central repository where you can get references to any model class, such as self.env['library.book'], without knowing the specific file that implements it. Controllers do not have such a repository, and you need to know which module and file implements the controller before you can extend it.

Then a **BooksExtended** class is declared based on the original **Books**. The class name is not relevant and is only a carrier for inheriting and extending the original class.

Then we (re)define a controller method to inherit from, in this case **list()**. It needs at least a simple **@http.route()** decorator to keep the route active. Without parameters, the routes defined in the parent class will be retained. But you can also add parameters to the **@http.route()** decorator to redefine or replace the class route.

The **list()** method takes a **kwargs** parameter and captures all the parameters in the **kwargs** dictionary. These are the parameters given in the URL, such as **?available=1**.

> **Tip**: ****kwargs** parameter includes all given parameters that may not be used, but will make our URL compatible with unexpected URL parameters. If you choose to specify specific parameters, when other parameters are set, the corresponding controller call will fail immediately and return an internal error.

The code of the list() method starts with **super()** to call the corresponding parent class method. The **Response** object calculated by the parent class method is returned, including the attributes and modules to be rendered, **template**, and the context **qcontext** used when rendering. However, the HTML has not yet been generated. HTML is only generated when the controller has finished running. Therefore, the **Response** attributes can still be modified before the final rendering is completed.

This method checks for a non-empty value for the key **available** in **kwargs**. If found, it filters out the non-borrowable books and updates **qcontext** in the recordset. So, when the controller processing is complete, the HTML is rendered with the updated book records, containing only the borrowable books.

### Inheriting QWeb template

Web templates are XML documents and like any other Odoo view type can use selector expressions, as we do with other view types like forms. QWeb templates are usually more complex, since they contain more HTML elements, and therefore most of the time use more varied **XPath** expressions.

To modify the actual display of the web page, you need to extend the QWeb template used. We will extend **library_app.book_list_template** to display more information about unavailable books.

A QWeb inheritance is a <template> element with an additional inherit_id attribute to identify the QWeb template to inherit from. In this case, it is library_app.book_list_template.

Follow these steps:

1. Add the **library_member/views/book_list_template.xml** file and add the following code:


    ```
    <odoo>
        <template id="book_list_extended"
            name="Extended Book List"
            inherit_id="library_app.book_list_template">
            <xpath expr="//span[@t-field='book.publisher_id']" position="after">
                <t t-if="not book.is_available">
                    <b>(Not Available)</b>
                </t>
            </xpath>
        </template>
    </odoo>
    ```

    The following example uses the **xpath** tag. Note that we could have used the equivalent simplified tag in this example, which is ` <span t-field="book.publisher_id" position=after> `

1. Declare the newly added data file in the plugin declaration file (i.e. **library_member/__manifest__.py**):


    ```
        "data": [
            "security/library_security.xml",
            "security/ir.model.access.csv",
            "views/book_view.xml",
            "views/member_view.xml",
            "views/library_menu.xml",
            "views/book_list_template.xml",
        ],
    ```

Visiting http://localhost:8069/library/books should now display additional visual information about unavailable books (not available). The page should look like this:

[![Figure 4.4: Book list webpage containing borrowable information](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9864337abb041d29c397a4469fdaece~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022051409051522.jpg)

**Figure 4.4:** A webpage showing a list of books available for borrowing

This concludes your review of how to inherit from various types of Odoo components, from data models to user interface elements.

## Summary

Extensibility is an important feature of the Odoo framework. We can build plugin modules to modify or add functionality to existing plugins that need to implement functionality at different levels in Odoo. Through inheritance, our projects can reuse and extend third-party plugin modules in a clean and modular way.

In the model layer, we use the _inherit model attribute to reference an existing model, and then perform modifications in place. The field objects in the model also support incremental definition, so that existing fields can be re-declared and only the attributes can be modified.

Other model inheritance mechanisms allow us to reuse data structures and business logic. Proxy inheritance uses the **delegate=True** attribute on many-to-one relationship fields (or the old-fashioned **inherits** model attribute) to make all the fields of the related model available and reuse their data structures. Prototypal inheritance uses the **_inherit** attribute plus other models to copy the functionality (data structure definitions and methods) of those models, and can use abstract mixin classes to provide a series of reusable functions like document discussion messages and followers.

In the view layer, the view structure is defined in XML, and XML elements are located (using XPath or Odoo simplified syntax) to inherit and add XML code snippets. Other records created by modules can also be modified by inherited modules, just reference the corresponding full XML ID and perform write operations on the corresponding fields.

In the business logic layer, you can use the same mechanism as model inheritance to inherit and redeclare the methods to be inherited. Within the method, Python's **super()** function can be used to call the code of the inherited method, and the added code can be run before or after it.

For front-end web pages, the display logic inheritance method in the controller is similar to the model method. The web page template is also a view containing an XML structure, so it can be inherited like other view types.

In the next chapter, we will go deeper into the model and explore all the capabilities it provides us.

## Further reading

The following are other references to the official documentation that can supplement the knowledge of module extension and inheritance mechanism:

- [Model inheritance](https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html)
- [View inheritance](https://www.odoo.com/documentation/15.0/developer/reference/backend/views.html)
- [Web Controller](https://www.odoo.com/documentation/15.0/developer/reference/backend/http.html)