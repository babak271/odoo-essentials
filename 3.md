# Chapter 3 Odoo 15 Development: Creating the First Odoo Application

Odoo development usually requires creating your own plug-in modules. In this article, we will create our first Odoo application and learn the steps to display and install applications in Odoo.

We will start with the basics of the development workflow, creating and installing new modules, and then upgrading the updated code in development iterations.

Odoo uses an MVC (Model-View-Controller)-like architecture. We will go into each layer to implement a book application.

This article mainly includes the following contents:

- Book Project Overview
- Step 1: Create a new plugin module
- Step 2: Create a new application
- Step 3: Add automated testing
- Step 4: Implement the model layer
- Step 5: Configure access permissions
- Step 6: Implement the background view layer
- Step 7: Implement the business logic layer
- Step 8: Implement the website user interface (**UI**)

In this way, we will gradually learn the basic components that make up an application and experience the iterative process of building an Odoo module from scratch.

## Technical Preparation

To learn this article, you need to install the Odoo server and start the service through the command line to install modules and run tests. If you do not have an Odoo development environment available, please refer to [Chapter 2 Odoo 15 Development Development Environment Preparation](2.md).

In this chapter we will create our first Odoo application from scratch, without any task starter code.

The code for this chapter is available in the ch03 directory of the [GitHub repository](source-code/ch03/).

> **Note:** The database name used in the sample code in this chapter is library. If you use another database name, please modify it yourself

## Book Project Overview

To better explain the knowledge points in this chapter, we will learn through cases. Let's create an Odoo application for managing books. This project will be used in subsequent chapters, and each article will be iterated to add new features to the application. In this article, we will create the first version of the book application.

The first feature to be implemented is the book catalog. The catalog allows us to keep records and details of books in the library. We want this catalog to be accessible to the public so that we can find books that can be borrowed.

The book should contain the following data:

- Title
- author
- Publishers
- Publication date
- Cover Image
- ISBN (International Standard Book Number): contains ISBN validity check
- Shelf mark: indicates whether the book can be released to the public

Following the convention of Odoo basic applications, the book application has two users and groups: book users and librarians. Users can perform daily operations, and administrators can also edit the configuration of the application.

In the book catalog section, we reserve the function of editing book records for administrators. As follows:

- Librarians can edit books
- Book users and website visitors can only browse books

This simple project contains all the main components to build an Odoo application. The first step is to create a module directory to hold the application's code and components.

## Step 1: Create a new plugin module

A plugin module is a directory containing files that implement Odoo functionality. It can add new functionality or modify existing functionality. A plugin directory must contain a declaration or description file `__manifest__.py`.

Some module plugins appear in Odoo as applications (apps). Applications are those top-level modules in the Odoo functional area, and we want this module to appear at the top level of the **Apps** menu. Odoo's basic applications are **CRM**, **Project** and **HR**. Non-application module plugins generally depend on an application and add or extend its functionality.

If a new module adds new or significant functionality to Odoo, it should generally be classified as an application, whereas if the module merely modifies the functionality of an existing application, it is a regular plugin module.

To develop a new module, we need:

1. Make sure the directory you are operating in is in the addons path of Odoo
1. Create a directory for the module and include the declaration file
1. If you plan to publish it externally, select a certificate for the module
1. Add module description information
1. Add an icon to the module. This is optional.

Then we can install the module, making sure the module is visible in the Odoo server and installed correctly.

### Prepare addons path

An addon module is a directory containing Odoo declaration files that creates a new application or adds functionality to an existing one. The addons directory can contain multiple addon modules. The addons path is an Odoo configuration that contains a list of directories where the Odoo server can look for addons.

The default addons path contains odoo/addons, which stores Odoo's official applications, and the odoo/odoo/addons directory, which contains base modules that provide core functionality. Usually, addons is modified to add one or more directories for custom development and community modules that you want to use.

The book application consists of multiple modules. This is a good practice because it reduces complexity by having smaller and more granular modules. We create a plugin directory for the project modules.

If you have studied [Chapter 2 Odoo 15 Development Environment Preparation](2.md), the Odoo server code should be stored in **~/work15/odoo/**. Custom plug-in modules are placed in their own directory, independent of the Odoo code.

We create a directory **~/work15/library** for the book application and add it to the add path. This can be done by directly editing the configuration file or the Odoo command line. The operation is as follows:

```
$ mkdir ~/work15/library
$ source ~/work15/env15/bin/activate
(env15) $ odoo \
--addons-path="~/work15/library,~/work15/odoo/addons" \
-d library -c ~/work15/library.conf --save --stop
```

At this time, the Odoo command line will return an error like this: **odoo: error: option --addons-path: no such directory: '/home/daniel/work15/library'** . This is because the directory is still empty and Odoo cannot find the add-on module in it. This problem will not exist after building the skeleton of the first book application module.

Here is a description of the Odoo command line parameters:

- The `--addons-path` parameter sets the directory where all Odoo modules are located.
- The `-d` or `--database` parameter sets the name of the database to use. If the database does not exist, it will be created and initialized using Odoo's basic database module.
- The `-c` or `--config` parameter sets the configuration file to use.
- `--save` parameter is used together with `-c` parameter to save the parameters to the configuration file.
- `--stop` is a short form of `--stop-after-init`, it will stop the Odoo server after all operations in the startup sequence are completed, returning to the command line.

If the plugin path parameter uses a relative path, Odoo will convert it to an absolute path before storing it in the configuration file.

> Changes in ODOO 15
>
> The created configuration file will use the default configuration as a template. In Linux systems, the default configuration file is **~/.odoorc**.

Odoo comes with a scaffold command that can quickly create a new module skeleton. You can use it to fill the library plugin directory with valid modules. Execute the following command to initialize the **library_app** module directory:

```
(env15) $ odoo scaffold library_app ~/work15/library
```

The **scaffold** command requires two parameters: the module directory name and the path to the creation location. The details of the **scaffold** command are relatively vague, you can execute `odoo scaffold --help` to view it.

Now execute the command to save the configuration file again, bringing the plugin directory **~/work15/library/**, and it will run successfully.

The first few log messages of the startup sequence contain the configuration used. They include INFO ? odoo: Using configuration file at..., which identifies the configuration file used, and INFO ? odoo: addons paths: [...], which lists the addons directories used. This is the first place to look when troubleshooting why Odoo cannot find a custom module.

### Create module directory

Continuing from the previous section, we have a ~/work15/library directory for storing Odoo modules. We add it to the plugin path so that the Odoo service can find the modules.

In the previous section, we also used Odoo's **scaffold** command to automatically create a skeleton structure for the **library_app** module directory, which contains the basic structure. The usage of the **scaffold** command is: `odoo scaffold <module> <addons-directory> `. The created module directory is as follows:

```
library_app/
├── __init__.py
├── __manifest__.py
├── controllers
│ ├── __init__.py
│ └── controllers.py
├── demo
│ └── demo.xml
├── models
│ ├── __init__.py
│ └── models.py
├── security
│ └── ir.model.access.csv
└── views
    ├── templates.xml
    └── views.xml
```

The module directory name is its technical name, in this case library_app. The technical name should be a valid Python identifier, that is, it starts with a letter and can only contain letters, numbers and underscores.

It contains several subdirectories, which serve as different components of the module. This subdirectory structure is not mandatory, but it is commonly used.

A valid Odoo plugin directory contains a `__manifest__.py` descriptor file. The module should also be importable, so it must contain a `__init__.py` file. These are the first two files you can see in the directory tree.

> **Tip:** In older versions of Odoo, the module description file was named __openerp__.py. This file is deprecated but still supported.

The description file contains a Python dictionary whose attributes describe the module. The files automatically generated by the scaffolding are as follows:

```
# -*- coding: utf-8 -*-
{
    'name': "library_app",

    'summary': """
        Short (1 phrase/line) summary of the module's purpose, used as
        subtitle on modules listing or apps.openerp.com""",

    'description': """
        Long description of module's purpose
    """,

    'author': "My Company",
    'website': "http://www.yourcompany.com",

    # Categories can be used to filter modules in modules listing
    # Check https://github.com/odoo/odoo/blob/15.0/odoo/addons/base/data/ir_module_category_data.xml
    # for the full list
    'category': 'Uncategorized',
    'version': '0.1',

    # any module necessary for this one to work correctly
    'depends': ['base'],

    #always loaded
    'data': [
        # 'security/ir.model.access.csv',
        'views/views.xml',
        'views/templates.xml',
    ],
    # only loaded in demonstration mode
    'demo': [
        'demo/demo.xml',
    ],
}
```

We'll discuss declaration files in more detail in the next section.

A module's `__init__.py` file should trigger the import of all Python files in the module. More specifically, it should import all Python files in the module's top level and in subdirectories containing Python files. Similarly, those subdirectories should also contain a `__init__.py` file that imports the Python resources in the subdirectories.

The top-level `__init__.py` file generated by the **scaffold** command has the following contents:

```
from . import controllers
from . import models
```

There are no Python files in the top level, only two subdirectories containing Python files: **controllers** and **models**. Looking at the tree structure of the module, you can see that both directories contain Python files and `__init__.py` files.

### Create a declaration file

The declaration file prepared by the scaffold command can be used as a guide, or we can create an empty declaration file.

A declaration file should be a Python file containing a dictionary. It is not mandatory to contain any keys, so an empty dictionary **{}** is valid as a file. In practice, we want to provide some basic information about the module, declare the author, and choose a distribution license.

The following can be used as initial content:

```
{
    "name": "Library Management",
    "summary": "Manage library catalog and book lending.",
    "author": "Alan Hou",
    "license": "AGPL-3",
    "website": "https://alanhou.org",
    "version": "15.0.1.0.0",
    "depends": ["base"],
    "application": True,
}
```

The key used here is the information displayed in the main label of the application form, as shown in the following figure:

[![Figure 3.1: Book management module application form](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46dddc10be984b21b7d5f9c36fec65c6~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022050606445499.jpg)

Figure 3.1: Application form of the library management module

We used the following description keys:

- name: module title
- summary: a one-line summary of the module
- author: The copyright author's name. This is a string, but can be a comma-separated list of names.
- license: This is the license under which the author authorizes the module to be distributed. **AGPL-3** and **LGPL-**3 are both well-known open source options. Own modules sold through the Odoo App Store should use Odoo's own license **OPL-1**. We will discuss licenses in more depth later in this chapter.
- website: A URL (Uniform Resource Locator) for more information about the module, which can help people find more documentation or provide a tracker for filing bugs and suggestions
- version: The version number of the module. The [version number convention](http://semver.org/) should be followed. It is recommended to prefix the module version number with the Odoo version, which helps to identify the Odoo version the module targets. For example, a 1.0.0 module targeting Odoo 15.0 would use version 15.0.1.0.0.
- depends: A list of dependencies of the plugin module. Installing the module will trigger the installation of these modules. If the module has no specific dependencies, it is usually made to depend on the **base** module, but this is not mandatory.
- application: A Boolean flag indicating whether the module is displayed as an application in the application list. Most extension modules add functionality to existing applications and set this value to **False**. The library management module is a new application, so it is set to **True**.

Be careful with the dependency list. Make sure to explicitly set all dependencies here, otherwise, the installation of the module may fail in a new database due to missing dependencies or due to a module being loaded later in the Odoo startup sequence than the current module. Both of these situations may occur when deploying to other machines, and it will be very time-consuming to identify and solve the problem.

The ` <div class="document"> ` line in Figure 3.1 is used for the long description of the module, which is currently empty. This will be discussed in the **Adding a Description** section.

There are some other description keys, which are used less frequently:

- **installable**: Indicates whether the module is installable. The default value is **True**, so there is no need to explicitly set it. If for some reason you want to keep the file in the plugin directory but disable the module, you can set it to **False**.
- **auto_install**: Can be set to **True** for glue modules. The installation of glue modules is triggered once when all dependencies are installed. For example, it can be used to automatically provide bridging functionality when two applications are installed on the instance at the same time.

### Set module category

Modules can be organized into categories, representing related areas of functionality. These categories are used to group add-on modules, as well as security groups.

If the plugin does not set a category, **Uncategorized** is used by default. The current book application is in this category.

We can see some Odoo categories in the left column of the **Apps** menu. There you can see the categories that the modules can use, as shown below:

[![Figure 3.2: Application list classification sidebar](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b6e97c850e74e029e13a715c4b26ba4~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022050606585486.jpg)

Figure 3.2: Application list category sidebar

Categories can be grouped, such as the **Project** application belongs to the **Services/Project** category.

If you use a non-existent category for a module, Odoo will automatically create it. We use this feature to create a new category for the book application: **Services/Library**.

Edit the `__manifest__.py` file and add a new **category**:

```
    "category": "Services/Library",
```

Classifications can also be used to organize security groups, which require corresponding XML IDs to reference them in the XML data files.

The XML ID assigned to a module category is automatically generated by adding base.module_category_ to the category name. For example, the XML ID generated for Services/Library is base.module_category_services_library.

We can view the XML ID of the application category by accessing the corresponding form view and then using the **View Metadata** option in the developer menu.

There is no menu item for application categories, but it is possible to access the category form through the security group form, as follows:

1. Open the **Settings** > **User** > **Groups** menu option and create a new test record.
1. Select an option from the drop-down list in the **Application** field and click Save. The operation process is shown in the figure below:\
    [![Figure 3.3: Application selection list of user group form](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39b55cd421054944ac21bc623fbf907b~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022050608245717.jpg)\
    Figure 3.3: Application selection list in the user group form
1. Click the **Application** link to open the details form corresponding to the selected category.
1. While in the category form, select **View Metadata** in the developer menu to view the assigned XML ID. \
    [![Select View Metadata in the developer menu to view the assigned XML ID](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/389d20be5cf24e6e912ad6657d85caca~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022050608262310.jpg)
1. You can delete the test group if you do not plan to use it.

Additionally, you can view the built-in categories and their XML IDs in the Odoo source code. The corresponding GitHub link is <https://github.com/odoo/odoo/blob/15.0/odoo/addons/base/data/ir_module_category_data.xml>.

### Select certificate

Choosing a module's certification is important and careful consideration should be given to which is the best option and its potential implications.

Software code is protected by copyright law, and the author reserves the right to use and modify it. This usually refers to you or your company. If other entities want to use your code safely, they must obtain a certificate authorization from the code author.

If you want to distribute your code freely and without charge, you need to include a license to allow others to use your code. Different licenses have different terms.

The most commonly used licenses for Odoo modules are **LGPL-3 (GNU's Not Unix (GNU) Lesser General Public License)** and **AGPL-3 (Affero General Public License)**. Both allow free distribution and modification, requiring that the author's signature should be carried and that the derived code should use the same license.

AGPL is a strong open source license that requires online services that use the code to share the source code with users. This license is popular in the community because it forces derived code to also be released under the AGPL. Thus, open source code cannot be built into commercial solutions, while the original author can benefit from other improvements.

LGPL is more permissive than AGPL, allowing commercial modifications without sharing the corresponding source code. Network and system integration components often choose this license, and their solutions may contain private licenses or components compatible with AGPL.

For more information about GNU licenses, please visit the [GNU official website](https://www.gnu.org/licenses/).

Although it is possible to sell GPL-licensed applications, this is not a common business model, because others can freely copy and distribute the code. Therefore, many modules sold in the Odoo App Store use their own licenses. Odoo recommends using its own license **OPL-1**.

For more information about Odoo licenses, please visit <https://www.odoo.com/documentation/user/legal/licenses/licenses.html>.

### Add description

Description is a long text that shows the function of the module. The description text supports generating rich text documents through **RST (reStructuredText)** format.

You can learn about RST at <https://docutils.sourceforge.io/rst.html>. This page contains a link to a quick manual that is worth saving: <https://docutils.sourceforge.io/docs/user/rst/quickstart.html>.

The following is a short example of an RST document:

```
Title
=====
Subtitle
--------
This is *emphasis*, rendered in italics.
This is **strong emphasis**, rendered in bold.
This is a bullet list:
- Item one.
- Item two.
```

One way to add a description is to use the description key in the module declaration file. Because the description will likely span multiple lines, it is best to add the content within triple quotes """ which is Python's syntax for multi-line strings.

Source code published on sites such as GitHub should contain a README file for visitors to easily view an introduction to the module. Therefore, in addition to the description in the manifest file, Odoo can also use a **README.rst** or **README.md** file. The file should be placed in the root directory of the module, at the same level as the `__manifest__.py` file.

Another solution is to use **HTML** (Hypertext Markup Language) document description files. Many modules published in the Odoo App Store use this approach to make a richer visual presentation of the application's functionality. **index.html** files should be placed in **static/description/** module subdirectory. Page resource files, such as images and **CSS**, should be placed in the same directory.

> Note: For modules that set **application** to **True**, only the **index.html** description is used and the description key is ignored.

### Add Icon

Modules can choose an icon of their own. This is especially important for modules created as apps, since apps will have an icon under the Apps menu.

You need to add the **static/description/icon.png** file to the module for use.

For the book application project, we reuse the icon of the existing Odoo application **Notes** and copy it to the **library_app/static/description** directory.

Use the following command in the command line:

```
$ cd ~/work15/library/library_app
$ mkdir -p ./static/description
$ cp ~/work15/odoo/addons/note/static/description/icon.png ./static/description/
```

### Installing new modules

Now we have a minimal plugin module. Nothing is implemented yet, but we can check that it works by installing it.

To install new modules, you should use the -d and -i options when starting the server. The -d or --database option ensures that we use the correct Odoo database. The -i or --init option accepts a comma-separated list of modules to install.

> **Changes in ODOO 11**
>
> When installing new modules, Odoo will automatically update the list of available modules in the currently configured add-on path. This was not the case until Odoo 10, when you had to manually update the module list before installing add-on modules. The module list is updated in the web client through a menu item in the **Apps** list.

Using the Odoo development environment prepared in this chapter and activating the Python virtual environment, you can install the **library_app** module with the following command:

```
(env15)$ odoo -c ~/work15/library.conf -d library -i library_app
```

We have added the -d library parameter to specify the correct database to install. This parameter is redundant if it is already specified in the configuration file. However, for safety reasons, it is best to specify the installed database on the command line.

> Tip: Watch the server log messages carefully to make sure the module is found and installed correctly. You should see **odoo.addons.base.models.ir_module: ALLOW access to module.button_install** in the logs and no warning messages.

To make the module installable, Odoo should be informed of the addons directory where the module is located. This can be confirmed by restarting the Odoo server and looking for the **odoo: addons paths:** log message printed on startup.

If the module cannot be found, this is usually because the plugin path is wrong. Double-check the plugin path used.

### Upgrading Modules

Developing modules is an iterative process where the source code is constantly modified and applied in Odoo.

You can find the module in the Apps list in the graphical user interface (**GUI**) and click the Upgrade button. This will reload the data files, apply the changes made and upgrade the database schema definition. However, if the changes were made to the Python logic, clicking Upgrade is not enough. You need to restart the Odoo server to reload the modified Python code. Sometimes, a module changes both the data files and the Python logic, in which case you need to do both at the same time.

To sum up:

- When you modify a model or its fields, an upgrade is required to apply the changes to the database schema.
- When modifying Python logic code, you need to restart to reload the code file.
- When you modify an XML or **CSV** file, you will need to perform an update to reapply the data in the file.

To avoid confusion and resistance when modifying Odoo code, the simplest solution is to restart the Odoo service through the upgrade command after modifying the code.

In the server instance terminal, stop the service by pressing Ctrl + C. Then start the service and upgrade the library_app module by running the following command:

```
(env15)$ odoo -c ~/work15/library.conf -d library -u library_app
```

The -u option (or --update in full) requires the -d option and accepts a comma-separated list of modules to be updated. For example, you could use -u library_app,mail. When a module is updated, all modules that depend on it are also updated.

Pressing the up arrow key will recall the previously used command. Therefore, in most cases, the combination of *Ctrl* + *C*, the up arrow key, and the *Enter* key will be used to repeat the same operation.

In recent Odoo versions, you can use the developer-friendly `--dev=all` parameter to automate this workflow. With this parameter, changes to data files will be immediately reflected in the running Odoo server, and changes to Python code will trigger Odoo code reloads. For details on this parameter, see the *Using Server-side Development Mode* section of [Chapter 2 Odoo 15 Development Preparation for Development Environment](2.md).

Now we have a module directory in place to host all the components that make up our app. Because this is an app, and not a technical module that adds functionality, we'll start by adding some of the foundational components that our app will need.

## Step 2: Create a new application

Some Odoo modules create new applications, while others add functionality or make modifications to existing applications. Although the technical components are basically the same in both, applications usually contain some characteristic elements. Since we are creating a book application, we should include these elements in our module.

The application should contain the following elements:

- Icon: used to display in the application list
- Top-level menu item: All menu items of the application are placed under it
- Application security group: Only open to designated users through access permissions

The application icon is the icon.png file placed in the static/description/ subfolder. It has been added in the **Add Icon** section.

Next, we add the top-level menu for our app.

### Add application top-level menu items

Since we are creating a new application, it should contain a main menu item, which is located in the drop-down menu in the upper left corner in the Community Edition, and appears as an additional icon in the main application switcher interface in the Enterprise Edition.

Menu items are view components that are added using XML data files. Define menu items by creating a views/library_menu.xml file and adding the following content:

```
<odoo>
    <!-- Library App Menu -->
    <menuitem id="menu_library" name="Library" />
</odoo>
```

The user interface, including menu items and operations, is stored in a data table for real-time reading and interpretation by the client.

The above file describes the records to be loaded into the Odoo database. The ` <menuitem> ` element indicates that a record is written on the **ir.ui.menu** model that stores Odoo menu items.

 The id attribute is also called XML ID, which is used to uniquely identify each data element for reference by other elements. For example, when adding a book submenu, you need to reference the XML ID of the parent menu item, that is, menu_library.

The menu item added here is very simple, using only one attribute, name. Other commonly used attributes are not used here. We will learn more about them in the **Implementing the Background View Layer** section later in this chapter.

The book module does not know about the existence of the XML data file. We need to use the data attribute in the declaration to add and load it into the Odoo instance. Edit the dictionary in the `_manifest__.py` file and add the following key:

```
    'data': [
        'views/library_menu.xml',
    ],
```

The **data** declaration key is a list of data files to be loaded when installing or upgrading the module. The file path is relative to the root directory where the declaration files are located.

To load these menu settings into the Odoo database, you need to upgrade the module. At this point, there will be no visible effect. The menu items will not be displayed because they do not contain any actionable submenus. They will be displayed when you add the submenus and the corresponding access rights.

> **Tip:** Items in the menu tree are displayed only if they have visible submenu items. Bottom-level menu items that open a view are only visible to users who have permission to access the corresponding model.

### Add permission group

Ordinary users need to obtain the corresponding permissions before using the functions. Odoo uses permission groups to achieve this. Permissions are granted to groups, and users are assigned to the groups.

Odoo applications usually have two groups with different access permissions:

- User access rights, for users who perform daily operations
- Administrator access rights, including access rights to all functions including configuration

The Books app also contains these two permission groups. We will implement them below.

Files related to access permissions are usually placed in the **security/** module subdirectory, so we need to create a **security/library_security.xml** file for permission definition.

Permission groups are grouped in the same categories used by plugin modules. You need to find the corresponding XML ID to set the category for the permission group. The method of finding the XML ID has been discussed in the **Setting module categories** section of this chapter. From that section, we know that the XML ID of **Services/Library** is **base.module_category_services_library**.

Next, we will add the book user permission group. It belongs to the **Library** category defined above, and its XML ID is **module_library_category**. It will also inherit the internal user permissions and be implemented on its basis. If you open the **View Metadata** option in the development menu in the user group form, you will see that its XML ID is **base.group_user**.

Now add the following XML to the **security/library_security.xml** file:

```
<odoo>
    <data>
        <!-- Library User Group -->
        <record id="library_group_user" model="res.groups">
            <field name="name">User</field>
            <field name="category_id" ref="base.module_category_services_library" />
            <field name="implied_ids" eval="[(4, ref('base.group_user'))]" />
        </record>
    </data>
</odoo>
```

This is a lot of information, so we will explain each element slowly. This XML adds a record to the group model **es.groups**. The record has three fields:

- **name:** Group name. This is a normal string.
- **category_id:** This is a relational field, so the ref attribute is used to connect to the previously created category via the XML ID.
- **implied_ids:** This is a one-to-many association field that contains a list of groups to cover the users in the group. Multiple fields use a special syntax, which will be introduced in this book [Chapter 5 Odoo 15 Development Import, Export and Module Data](5.md). We use number 4 to connect to the existing internal user group XML ID, base.group_user.

> **Changes in ODOO 12**
>
> The **User** form now has a **User Type** section, visible only when developer mode is enabled. This allows us to select one of the mutually exclusive options: **Internal User**, **Portal** (external users, such as customers), and **Public** (anonymous visitors to the site). This change was made to avoid misconfigurations in previous versions, where internal users could be accidentally added to the **Portal** and **Public** groups, thus reducing their access rights.

Next we create the admin group. Grant all permissions to the user group and reserve other permissions for application administrators. So we want to inherit the library user **library_group_user**.

Edit the **security/library_security.xml** file and add the following XML in the **` <odoo> `** element:

```
        <!-- Library Manager Group -->
        <record id="library_group_manager" model="res.groups">
            <field name="name">Manager</field>
            <field name="category_id" ref="base.module_category_services_library" />
            <field name="implied_ids" eval="[(4, ref('library_group_user'))]" />
            <field name="users"
                   eval="[(4, ref('base.user_root')),
                   (4, ref('base.user_admin'))]" />
```

Here, the **name**, **category_id**, and **implied_ids** fields appear as before. The **implied_ids** field is set to link to the book user group and inherit its permissions.

The **users** field is also set, granting the authorization to the administrator (**admin**) and Odoobot users.

> **Changes in ODOO 12**
>
> Starting from Odoo 12, there is a system root user, which is not displayed in the user list and is used internally by the framework when privilege escalation (**sudo**) is required. Admin can log in to the system and should have access to all functions, but can no longer bypass access restrictions like the system root user. In Odoo 11 and previous versions, the **admin** user is also the internal root super user.

You also need to add the XML file to the declaration file:

```
    "data": [
        "security/library_security.xml",
        "views/library_menu.xml",
    ],
```

Note that library_security.xml is added before library_menu.xml. The order in which the data files are loaded is very important, because we can only reference identifiers that have been defined. Menu items often reference security groups, so it is recommended to put the security group definition file before the menu and view files.

The next step is to add the Python code that defines the application model. But before that, let's add some test cases according to the theory of test-driven development (**TDD**).

[![Add permission group](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8573cb7b7b53443ea9e1aa8a4c28a7d3~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022050700574356.jpg)

## Step 3: Add automated tests

Programming best practices include automated testing of your code, which is especially important for dynamic languages ​​like Python, because there is no compilation step, and syntax errors are only reported when the interpreter actually runs the code. A good editor can help us find problems in advance, but it cannot help us determine whether the code works as expected like automated testing.

TDD theory tells us to write tests first, check for errors, and then develop the code until it passes the tests. Inspired by this approach, we add module tests before adding actual functions:

Odoo supports automated testing based on Python's built-in unittest library. Here we quickly introduce automated testing, and there is a more detailed explanation in [Chapter 8 Odoo 15 Development Business Logic - Business Process Support](8.md).

> **Changes in Odoo 12**\
> As of Odoo 11, tests could be expressed using YAML (**YAML Ain't Markup Language**) files. However, support for YAML files has been removed in Odoo 12, so this approach can no longer be used.

Tests need to meet certain conditions to be discovered and executed by the test runner. The conditions are as follows:

1. Tests are placed in the **tests/** subdirectory. Unlike regular Python code, this directory does not need to be imported in the top-level `__init__.py`. The test engine will look for the test directory in the module and then run it.
1. The test code file name should start with test_ and be imported through `tests/__init__.py`. The test code is placed in a class derived from several test objects available in the Odoo framework and imported by **odoo.tests.common**. The most commonly used test class is **TransactionCase**. The test object uses the **setUp()** method to initialize the data used by the test case.
1. Each test case is a method starting with **test_**. For **TrasactionCase** test objects, each test is an independent transaction, running the setup step at the beginning and rolling back at the end. Therefore, the following steps will not know the changes made by the previous test.

> **Tip:** It is easier to use demo data for the test to complete the configuration phase, but it is not a good practice because the test cases can only be run in the database where the demo data is installed. If you prepare all the test data in the test configuration, then the test can be run in any database, including an empty database or a copy of the production database.

We plan to add a **library.book** model to our application. Let's add a simple test to verify that the new book is created correctly.

### Add test cases

Let's add a simple test that checks the creation of a book. This requires adding some configuration data and adding a test case. The test case simply determines whether the value of the **active** field is the expected default value **True**.

Follow these steps:

1. Add the following code in `tests/__init__.py`:


    ```
    from . import test_book
    ```

1. Then add the actual test code, located in the **tests/test_book.py** file, as follows:\


    ```
    from odoo.tests.common import TransactionCase
    class TestBook(TransactionCase):
        def setUp(self, *args, **kwargs):
            super().setUp(*args, **kwargs)
            self.Book = self.env['library.book']
            self.book1 = self.Book.create({
                "name": "Odoo Development Essentials",
                "isbn": "879-1-78439-279-6"
            })
        def test_book_create(self):
            "New Books are active by default"
            self.assertEqual(self.book1.active, True)
    ```

    The setUp() method gets a pointer to a Book model object and uses it to create a new book.

The test_book_create test case adds a simple test that checks the default value of the active field of the created book. It is entirely possible to create the book in the test case, but we chose the initialization method. The reason is that we plan to use this book in other test cases, and creating it in setup can reduce duplication of code.

### Run the test case

Use the `--test-enable` parameter when installing or upgrading the module to run the test when starting the service, as follows:

```
(env15) $ odoo -c ~/work15/library.conf -u library_app --test-enable
```

The Odoo server will look for a **tests/** subdirectory in the upgraded module and run the tests. Now the tests will throw errors and you can see **ERROR** messages related to the tests in the server log. This problem can be solved by adding a book model to the module.

Now it's time to add the business logic to the test. Ideally, every line of code should correspond to at least one test case.

### Test business logic

We are going to add some logic to check the validity of the ISBN. So let's add a test case to see if we can correctly check the validity of the ISBN of the Odoo Developer's Manual 1st Edition. The check method is implemented by the check_isbn() method, which returns True or False.

Add a few more lines of code after the test_book_create() method in the tests/test_book.py file:

```
    def test_check_isbn(self):
        "Check valid ISBN"
        self.assertTrue(self.book1._check_isbn)
```

It is recommended to add a test case for each operation that needs to be checked. Don't forget that when using **TransactionCase** testing, each test will be run independently, and the data created or modified by the test case will be rolled back at the end of the test.

Of course, running the test now will still fail because the functionality being tested has not yet been implemented.

### Test access permissions

Access rights can also be checked to determine whether the user is properly authorized.

By default, tests in Odoo are executed by the internal user `__system__`, which has no permissions. So we need to change the user that executes the tests to check if the correct access permissions are granted. This is done by modifying the execution environment in self.env, just change the user property to the user you want to run the tests as.

We can modify the test implementation. Edit the setUp method in tests/test_book.py as follows:

```
    def setUp(self, *args, **kwargs):
        super().setUp(*args, **kwargs)
        user_admin = self.env.ref('base.user_admin')
        self.env = self.env(user=user_admin)
        self.Book = self.env['library.book']
        self.book_ode = self.Book.create({
            'name': 'Odoo Development Essentials',
            'isbn': '879-1-78439-279-6'})<br>
```

We added two lines to the **setUp** method. The first line uses the XML ID to find the **admin** user record. The second line modifies the environment **self.env** used to run the test, changing the active user to the **admin** user.

No other changes are required to the tests you wrote. They are run the same way, but as the admin user because of the changed environment.

The book application now has two basic tests, but they fail when run. Next we should add code that implements the functionality so that the tests pass.

## Step 4: Implement the model layer

Models describe and store business object data, such as customer relationship management (CRM) opportunities, sales orders, or partners (customers, suppliers, etc.). Models describe a set of fields and can also add specific business logic.

The model data structure and associated business logic are presented in Python code, using object classes derived from Odoo template classes. Models are mapped to data tables, and the Odoo framework handles all database interactions, not only keeping the database structure and objects in sync, but also translating all transactions into database instructions. The responsible framework component is the Object Relational Mapping (ORM) component.

Our application is used to manage books, so we need a book catalog model.

### Create the data model

The Odoo Development Guide mentions that the model's Python file should be placed in the models subdirectory, with one file for each model. So we create the models/library_book.py file in the library_app module directory.

> **Tip:** For the official Odoo Coding Guidelines, please visit the [Odoo official website](http://www.odoo.com/documentation/15.0/reference/guidelines.html). Another related coding standard document is the [OCA Coding Guidelines](https://odoo-community.org/page/contributing).

First you should make the module use the **models/** directory. This means that it should be imported by Python when Odoo loads the module. To do this, edit the module's main `__init__.py` file and add the following:

```
from . import models
```

Also, the models/ subdirectory should contain a `__init__.py` file to import the code files you want to use. Add the models/__init__.py file with the following content:

```
from . import library_book
```

Now we can create models/library_book.py and add the following content:

```
from odoo import fields, models
class Book(models.Model):
    _name = 'library.book'
    _description = 'Book'
    name = fields.Char('Title', required=True)
    isbn = fields.Char('ISBN')
    active = fields.Boolean('Active?', default=True)
    date_published = fields.Date()
    image = fields.Binary('Cover')
    publisher_id = fields.Many2one('res.partner', string='Publisher')
    author_ids = fields.Many2many('res.partner', string='Authors')
```

The first line is the Python code import statement, making the models and fields objects of the Odoo core available here.

The second line declares the new **library.book** model. This is a class that inherits from **models.Model**.

The next few lines are indented. Python code is defined by indentation level, that is, these lines are the definition of **Book** class. Class names are in camel case, which is a Python convention. The actual Python class name used has nothing to do with the Odoo framework. The model ID relevant to Odoo is the **_name** attribute, which is defined in the class.

The two lines following the class name, starting with an underscore, declare the attributes of the Odoo class. **_name** defines a unique **ID** (**UID**) that is used to reference the model in Odoo. Model IDs use dots ( **.** ) to separate keywords.

> **Tip:** Only model names use periods (.) to separate keywords. Other names such as modules, XML identifiers, and database table names all use underscores (_).

Next is the _description model attribute. This is the display name of the model record, and is used in user messages referring to the model record. It is not mandatory to have this field, but a warning message will be displayed in the server log if it is missing.

The last 7 lines declare the model. We can look at the most commonly used field types. Scalar values ​​can use **Char**, **Boolean**, **Date** and **Binary** types. Relational fields can use **Many2one** and **Many2many**.

The **name** field is used as the data model title, here the book title.

The active field is used for valid records. By default, only valid records are displayed, and invalid records are hidden. This is suitable for situations where you need to hide records that are no longer used but want to keep them in the database for historical reasons.

> **Tip:** **name** and **active** are special field names. They have special uses for Odoo by default. **name** is used as the record display name by default, which is displayed when another model references it. The **active** field is used to filter out invalid records in the user interface.

**publisher_id** is a many-to-one relational field, called a foreign key in the database. It stores a relation to another model record, in this case the **res.partner** model. It is used to associate publishing companies. Usually the name of the many-to-one field ends with **_id**.

**author_ids** is a many-to-many relational field. It can store the relation between one or more records in other models. In this example, it is used for the author of a book, which can be associated with multiple records in the **res.partner** model. At the database level, this data is not stored in a table field, but in an automatically created auxiliary data table to store the relationship between the two tables. Usually the name of the many-to-many field ends with **_ids**.

There are two associations between the Book and Partner models. The Partner model is a built-in model in the Odoo framework that is used to store people, companies, and addresses. We use it to store publishers and authors.

Now we can use these changes by upgrading the library application. Here is the command to upgrade the library_app module in the library database:

```
(env15)$ odoo -c ~/work15/library.conf -d library -u library_app
```

There is no menu for accessing the book model yet. We will add it later in this chapter. To check if the newly created model is created correctly in the database, you can use the **Technical** menu. In the **Settings** top-level menu, go to **Technical** > **Database Structure** > **Models**, search for the **library.book** model, and click it to view its definition, as shown below:

[![Figure 3.4: Library.book model view under the Technical menu](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0251e0a2538e40ffa7bb90e4e32e1dcb~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022050704162045.jpg)

Figure 3.4: Library.book model view under the Technical menu

We should see the model listed and confirm that it contains the fields defined in the Python file. If you don't see it, please upgrade and restart, and carefully check the server log to see if there are any messages loading the book application and any warning messages about the Odoo database.

In the list of fields in library.book, we can see some additional fields that are not declared. These special fields are automatically added by Odoo for a model. They are:

- id is a unique database identifier for each record in the model
- create_date and create_uid record the creation time and creator respectively
- display_name provides the text display for the record used. If other records reference it, it will be calculated and default to the text in the name field.
- write_date and write_uid indicate the most recent modification time and the person who modified it.
- __last_update is a calculated field that is not stored in the database and is used for concurrency detection

Now the book model is created in the database, but users still can't access it. We need to add a menu, but adding a menu alone won't work. To display the menu, we first need to grant access to the new model.

## Step 5: Configure access permissions

The library.book model has been created in the database, so when you load the service, you may notice a warning message in the output log:

```
The model library.book has no access rules, consider adding one.
```

The prompt message is clear, our new model has no permission rules, so no one can use it. We have added permission groups to the application, now we need to grant them access to the application model.

> **Changes in ODOO 12**
>
> **admin** follows the same access rights rules as other users, only superusers like root are not restricted. You need to grant permission before accessing new models. This was not the case in Odoo 11 and before. In these earlier Odoo versions, the **admin** user was also an internal superuser and was not subject to the permission rules. This meant that **admin** could automatically use new models.

### Add access control permissions

To understand what information is needed to add permissions to a model, go to Settings > Technical > Security > Access Rights, as shown below:

[![Figure 3.5: Access permission list in the Technical menu](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb33df5890514a91a237c3f58b212d27~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/202205070538382.jpg)

Figure 3.5: Access rights list in the Technical menu

These access permissions are also called access control lists (ACLs). In the figure above, you can see the ACLs of some models. They indicate what actions the permission group can perform on records: read, write, create, and delete.

> **Changes in Odoo 14**
>
> Temporary models used for interactive wizards now also need to be given access rights to the user group. In previous Odoo versions, this was not required and users had access to these models by default. It is recommended to grant read, write and create permissions, but not delete permissions (**1,1,1,0** in the CSV file).

Our book application will give the Users group permissions to write, read, and create book records, while Administrators will have all permissions, including the ability to delete records.

This data can be provided via a module data file, loading records into the **ir.model.access** model. The name of the CSV data file must match the model ID that the data is to be loaded into.

So we need to add a new security/ir.model.access.csv file with the following content:

```
id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_book_user,BookUser,model_library_book,library_group_user,1,1,1,0
access_book_manager,BookManager,model_library_book,library_group_manager,1,1,1,1
```

The first line of the file contains the field names. The CSV file contains the following columns:

- id is the external identifier of the record (also called XML ID), which must be unique within the module.
- name is a descriptive title. It is informative and a unique name is recommended.
- model_id is the external identifier of the authorized model. Models have XML IDs automatically generated by the ORM, for library.book the identifier is model_library_book.
- group_id specifies the authorized permission group. We authorize the permission groups created above: library_group_user and library_group_manager.
- The perm_... field authorizes read, write, create, or unlink operations. Use **1** to represent **yes**/**true**, **0** to represent **no**/**false**

Don't forget to add the import of the new file in the data attribute of `__manifest__.py`. The modified file should look like this:

```
    'data': [
        'security/library_security.xml',
        'security/ir.model.access.csv',
        'views/library_menu.xml',
    ],
```

As usual, upgrade the module to make the changes take effect in the Odoo database. At this time, the warning message will disappear.

At this point, the **admin** user can access the book model. So every test should pass. Let's run it:

```
(env15) $ odoo -c ~/work15/library.conf -u library_app --test-enable
```

You should see one test pass and one fail.

ACL access rights are granted at the model level, but Odoo also supports hierarchical access rights through record rules. This is explained in the next section.

### Row-level permission rules

Permission rules define filters that restrict the records that a permission group can access. For example, a salesperson can only view his own quotes, or an accountant can only view the accounting records of the authorized company.

To demonstrate this functionality, we restrict book users from accessing inactive books. Although these books are hidden by default, they will still be accessed when filtering by the condition where **active** equals **True**.

Recording rules are located under the **Technical** menu, at the same level as **Access Rights**. They are stored in the **ir.rule** model.

The fields required to define a recording rule are as follows:

- **name**: A unique title, preferably unique.
- **model_id**: A reference to the model to which the rule applies.
- **groups**: A reference to the permission groups to which the rule applies. This is optional, if not set the rule is considered global (the **global** field is automatically set to **True**). Global rules work differently and impose restrictions that cannot be overridden by non-global rules. Use a specific syntax to write to the multi-field.
- **domain_force**: The domain filter used for access restriction, taking the domain filter expression tuple list syntax used by Odoo.

To add logging rules to the library application, edit the security/library_security.xml file and add another section ` <data> ` before the closing tag ` </odoo> `:

```
    <data noupdate="1">
        <record id="book_user_rule" model="ir.rule">
            <field name="name">Library Book User Access</field>
            <field name="model_id" ref="model_library_book" />
            <field name="domain_force">
                [('active','=',True)]
            </field>
            <field name="groups" eval="[(4,ref('library_group_user'))]" />
        </record>
    </data>
```

Record rules are enclosed in a `<data noupdate="1">` element, which means that these records will be created when the module is installed, but will not be overwritten when the module is updated. This allows the rules to be customized later without losing the customizations when performing a model upgrade.

> **Tips:** noupdate="1" will cause trouble during development, because the fixes and modifications will not be updated when the module is upgraded. There are two ways to deal with it. One is to temporarily use **noupdate="0"** during development, and change it to **noupdate="1"** after completion. The other is to reinstall the module without upgrading. This can be achieved by replacing **-u** with **-i** in the command line for the installed module.
>
> Data will not be rewritten in the database. So during development, you can change it to noupdate="0" to get the expected results.

The **groups** field is a many-to-many association, using the special syntax required for many fields. It is a list of tuples, each of which is a command. In this example, **(4, x)** is used, and **4** means that the next referenced record will be appended to the value. The referenced record is **library_group_user**, which is the library user group. [Chapter 6 Odoo 15 Development Model - Structured Application Data](6.md) will discuss the syntax for writing to multiple fields.

Scope expressions also use a special syntax, a list of ternaries, each of which specifies a filter condition. The syntax of the scope filter is explained in [Chapter 7 Odoo 15 Development Recordset - Using Model Data](7.md).

Now that the book model is accessible to the user, let's add the user interface, starting with the menu.

[![Row-level permission rules](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c658f5901be84e6d854447c8d1557145~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022050708290016.jpg)

## Step 6: Implement the background view layer

The view layer is a description of the user interface. The view is defined in XML, and the web client framework generates a data-aware HTML view.

Menu items can perform window actions that render views. For example, the Users menu item handles an action also named Users, and then uses a combination of lists and forms.

There are several view types available. The 3 most commonly used views are List View (also called Tree View for historical reasons), Form View, and Search View in the upper right corner of the search box.

In the following sections, we will make improvements step by step. We need to frequently upgrade the module to make the changes take effect. We can also use the `--dev=all` server-side parameter, so that there is no need to upgrade the module during development. When using this parameter, the view definition is read directly from the XML file, and the changes made can take effect immediately in Odoo without upgrading the module. The `--dev` parameter is explained in detail in [Chapter 2 Odoo 15 Development Development Environment Preparation](2.md).

> **Tip:** If the module upgrade fails due to XML errors, don't panic! Carefully read the error messages in the server log to find the problem. If it's troublesome, comment out the recently edited XML content or delete the XML file in `__manifest__.py`, update again, and the service should start correctly.

According to the Odoo Developer Guide, the XML files for the user interface should be placed in the **views/** subdirectory.

Next, let’s create the interface of our book application.

### Adding menu items

Now that our app has a model for storing book data, we want to access it in the user interface. The first thing to do is to add the corresponding menu item.

Edit the views/library_menu.xml file and add the following window actions and module menu item records:

```
    <!-- Action to open the book list -->
    <record id="action_library_book" model="ir.actions.act_window">
        <field name="name">Library Books</field>
        <field name="res_model">library.book</field>
        <field name="view_mode">tree,form</field>
    </record>
    <!-- Open the menu for the book list -->
    <menuitem id="menu_library_book"
              name="Books"
              parent="menu_library"
              action="action_library_book" />
```

This data file contains two records added to Odoo:

- The ` <record> ` element defines a client window action that enables the list view and form view, in that order, when opening the **library.book** model.
- The ` <menuitem> ` of the book runs the previously defined action_library_book action.

Now update the module again to make the changes take effect. You may need to refresh the browser page to see the new menu. Once done you should see the top-level menu **Library** with a sub-menu **Books**.

Although the interface views have not yet been defined, Odoo will automatically generate views so that we can view and edit data immediately.

Clicking the **Library** > **Books** menu will display a basic list view, and clicking the **Create** button will display the following form view:

[![Figure 3.6: Form view automatically generated for the book application](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a551629c39b406a9f708f5bf1919cf1~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/202205070711594.jpg)

Figure 3.6: The automatically generated form view for the book application

Odoo automatically generates views for us, but they are not perfect. We may want to create views ourselves, starting with the book form view.

### Create the form view

Views are stored as data records in the ir.ui.view model in the database. So we need to add a data file containing a `<record>` element that describes the view.

Add a new **views/book_view.xml** file to define the form view:

```
<odoo>
    <record id="view_form_book" model="ir.ui.view">
        <field name="name">Book Form</field>
        <field name="model">library.book</field>
        <field name="arch" type="xml">
            <form string="Book">
                <group>
                    <field name="name" />
                    <field name="author_ids" widget="many2many_tags" />
                    <field name="publisher_id" />
                    <field name="date_published" />
                    <field name="isbn" />
                    <field name="active" />
                    <field name="image" widget="image" />
                </group>
            </form>
        </field>
    </record>
</odoo>
```

The ir.ui.view record has an id field that defines the XML ID used when other records reference it. The view record sets values ​​for three fields: name, model, and arch.

This is a view of the library.book model, named Book Form. This name is for informational purposes only. It does not need to be unique, but should make it easy to tell which record it refers to. You can actually omit the name entirely, and it will be automatically generated based on the model name and view type.

The most important field is arch, because it contains the definition of the view and needs to be explained in detail.

Each of these elements is a ` <form> ` tag. It declares the type of view being defined, and other elements are wrapped around it.

Next, we define groups in the form using the ` <group> ` element. It can contain ` <field> ` elements and other elements, including nested group elements. The group adds a two-column invisible style, which is suitable for the field because it occupies two columns, one for the label file and the other for the input box.

Our form consists of only one ` <group> ` element, and we add a ` <field> ` element for each field to display. Fields automatically use the corresponding default widget, such as the date field uses the date selection widget. In some cases, we may add the **widget** attribute to use a specific widget. The **author_ids** field does this, using an email that displays the authors as a list of tags, and the **image** field uses the corresponding email that handles images. [Chapter 10 Odoo 15 Development Background View - Designing the User Interface](10.md) will explain the view elements in detail.

Don't forget to add the newly created file to the data of the declaration file, otherwise our module will not be able to recognize and load the file. The code is as follows:

```
    'data': [
        'security/library_security.xml',
        'security/ir.model.access.csv',
        'views/library_menu.xml',
        'views/book_view.xml',
    ],
```

View files usually come after permission files and before menu files.

To load the changes into the Odoo database, you need to update the module. You also need to reload the page to see the changes, either by clicking the menu item again or refreshing the page (the shortcut key is F5 in most browsers).

[![Book application form view](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/710b0830c22b4d199084b4f03af278a8~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022050708273846.jpg)

### Business Document Form View

The above creates a basic form view, but it can be improved. For the document model, Odoo has a presentation style that simulates paper. The form consists of two top-level elements: the ` <header> ` element that contains the action buttons and the ` <sheet> ` element that contains the data fields.

You can use this to modify the base ` <form> ` element defined in the previous section:

```
            <form string="Book">
                <header>
                    <!-- Add button here-->
                </header>
                <sheet>
                    <!-- Content goes here: -->
                    <group>
                    <field name="name" />
                    <field name="author_ids" widget="many2many_tags" />
                    <field name="publisher_id" />
                    <field name="date_published" />
                    <field name="isbn" />
                    <field name="active" />
                    <field name="image" widget="image" />
                </group>
                </sheet>
            </form>
```

Forms can contain buttons, which are used to perform actions. Such buttons can run window actions, usually opening another form, or running a Python method. Buttons can be placed in the top ` <header> ` area, or elsewhere in the form. Let's learn how to do this.

### Add action button

We will demonstrate adding a button in the header to check whether the ISBN of a book is valid. The code used is a method in the book model named **button_check_isbn()**.

We have not added this method yet, but we can first add a corresponding button to the form. The code is as follows:

```
<header>
    <button name="button_check_isbn" type="object"
        string="Check ISBN" />
</header>
```

The basic properties of a button are:

- string: defines the text displayed on the button
- type: the type of action to be performed, **object** or **action**
- name: The ID of the action being run. For **object**, name is the method name, and **action** uses the action's record ID
- class: optional attribute for applying CSS styles, the same as in HTML

### Use groups to organize forms

The ` <group> ` tag can be used to organize form content. The ` <group> ` element creates an invisible two-column grid. Field elements added to it overlap vertically because each field occupies two cells: one for the label and one for the input field. Adding two ` <group> ` elements inside a ` <group> ` element will produce a two-column layout of fields.

We will use it to organize the book form. Modify the content in ` <sheet> ` as follows:

```
<sheet>
    <group name="group_top">
        <group name="group_left">
            <field name="name" />
            <field name="author_ids" widget="many2many_tags" />
            <field name="publisher_id" />
            <field name="date_published" />
        </group>
        <group name="group_right">
            <field name="isbn" />
            <field name="active" />
            <field name="image" widget="image" />
        </group>
    </group>
</sheet>
```

Here the ` <group> ` element has a **name** attribute added to it, giving it an identifier. This is not mandatory, but recommended, as it makes it easier to reference them in extended views.

### Complete form view

At this point the XML definition of the book form view is as follows:

```
<form>
    <header>
        <button name="button_check_isbn" type="object"
            string="Check ISBN" />
    </header>
    <sheet>
        <group name="group_top">
            <group name="group_left">
                <field name="name" />
                <field name="author_ids" widget="many2many_tags" />
                <field name="publisher_id" />
                <field name="date_published" />
            </group>
            <group name="group_right">
                <field name="isbn" />
                <field name="active" />
                <field name="image" widget="image" />
            </group>
        </group>
    </sheet>
</form>
```

The action buttons are not available yet because we need to add business logic. We will add it later in this chapter.

[![Form view modification results](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce4dac72cb994ff88f5b41735f220246~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022050710312594.jpg)

### Add list view and search view

To define a list view use the ` <tree> ` view type. Its structure is pretty straightforward. The ` <tree> ` top-level element should contain the fields to be presented as columns.

We can add the definition of ` <tree> ` view in **book_view.xml** file:

```
    <record id="view_tree_book" model="ir.ui.view">
        <field name="name">Book List</field>
        <field name="model">library.book</field>
        <field name="arch" type="xml">
            <tree>
                <field name="name" />
                <field name="author_ids" widget="many2many_tags" />
                <field name="publisher_id" />
                <field name="date_published" />
            </tree>
        </field>
    </record>
```

The above defines a list with four columns: name, author_ids, publisher_id, and date_published.

In the upper right corner of the list, Odoo displays a search box. The search fields and available filters are defined by the ` <search> ` view.

Also add in the book_view.xml file:

```
    <record id="view_search_book" model="ir.ui.view">
        <field name="name">Book Filters</field>
        <field name="model">library.book</field>
        <field name="arch" type="xml">
            <search>
                <field name="publisher_id" />
                <filter name="filter_active"
                    string="Active"
                    domain="[('active','=',True)]" />
               <filter name="filter_inactive"
                    string="Inactive"
                    domain="[('active','=',False)]" />
            </search>
        </field>
    </record>
```

The search view is defined using two elements: ` <field> ` and ` <filter> `.

The ` <field> ` element defines the field that is automatically searched when you enter it in the search box. Here, **publisher_id** is added to automatically display the search results of the publisher field. The ` <filter> ` element adds predefined filter conditions, which users can switch by clicking. The filter conditions use Odoo's scoped filter syntax. [Chapter 10 Odoo 15 Development Background View - Designing the User Interface](10.md) will be further introduced.

> **Changes in Odoo 12**\
> ` <filter> ` is now required to contain a name="..." attribute, uniquely identifying each defined filter. Without it, XML validation will fail and the module will not install or upgrade.

Now we have the basic components of the book application (model and view layers). Next, we will add the business logic layer and add the code that makes the **Check ISBN** button work.

## Step 7: Implement the business logic layer

The business logic layer writes the business rules of the application, such as validation and automated operations. Now let's add logic to the **Check ISBN** button. To do this, write a method in the Python class of the **library.book** model.

### Add business logic

Modern ISBNs contain 13 digits, and the last digit is a check digit calculated from the first 12 digits. If **digits** contains the first 12 digits, the Python code returns the corresponding check digit:

```
ponderations = [1, 3] * 6
terms = [a * b for a, b in zip(digits, ponderations)]
remain = sum(terms) % 10
check = 10 - remain if remain != 0 else 0
return digits[-1]
```

A few tweaks to the above code will become the core code of the validation function. It should be a method in the **class Book(...)** object. We will add a method to check the ISBN of the record and return **True** or **False**, as follows:

```
      def _check_isbn(self):
        self.ensure_one()
        isbn = self.isbn.replace('-', '') # Added by Alan for compatibility
        digits = [int(x) for x in isbn if x.isdigit()]
        if len(digits) == 13:
            ponderations = [1, 3] * 6
            terms = [a * b for a,b in zip(digits[:12], ponderations)]
            remain = sum(terms) % 10
            check = 10 - remain if remain !=0 else 0
            return digits[-1] == check
```

Note that this method cannot be used directly from a form button, as it provides no view clues to the result. We will add another method below.

> **Changes in ODOO 13**
>
> Removed the **@api.multi** decorator from the Odoo API. It is no longer usable. Note that this closure was available in previous Odoo versions, but it is not necessary. It works the same whether it is included or not.

We use Odoo's **ValidationError** exception to inform the user of the validation result. First, we need to import the exception class. Edit the **models/library_book.py** Python file and add it at the top of the file as follows:

```
from odoo.exceptions import ValidationError
```

Then add the following code to the Book class in the models/library_book.py file:

```
    def button_check_isbn(self):
        for book in self:
            if not book.isbn:
                raise ValidationError('Please provide an ISBN for %s' % book.name)
            if book.isbn and not book._check_isbn():
                raise ValidationError('%s is an invalid ISBN' % book.isbn)
        return True
```

Here, **self** represents a record set. We can iterate over each record and perform detection.

This method is used for form buttons, so in theory **self** is a single record, and there is no need to use a **for** loop. In fact, we do something similar in the auxiliary method **_check_isbn()**. If you use this method, it is recommended to add **self.ensure_one()** at the beginning of the method to report an error sooner or later when **self** is not a single record.

But we chose a **for** loop to support multiple records, so that the code can perform multiple verification functions that may be desired later.

The code iterates through each selected book record and if the book's ISBN has a value, it checks its validity. If it is invalid, a warning message is thrown to the user.

Model methods do not need to return any value, but we should at least let them return **True**. Because not all clients that implement XML Remote Procedure Call (**RPC**) support None/Null values, an error may be thrown if the method does not return a value.

At this point, you can update the module and run the test again, adding the `--test-enable` parameter to determine whether the test passes. You can also test it online by going to the book form and clicking the button with the correct and incorrect ISBNs.

The book application already contains all the backend functionality needed for the first iteration. I have implemented Odoo's multiple layers of components: models, views, and business logic. But Odoo also supports the creation of external-facing pages. In the next section, we will create our first Odoo web page.

## Step 8: Implement the website user interface (**UI**)

Odoo also provides a web development framework for developing functions that are deeply integrated with backend applications. The first step is to create a simple web page that displays a list of valid books.

The response is when the page **http://my-server/library/books** is requested, so **/library/books** is the URL endpoint for the implementation.

A web controller is a component responsible for rendering a web page. A controller is a Python method derived from http.Controller. This method uses the @http.route controller to bind to one or more URL endpoints. When any of these URLs is accessed, the controller code is executed and the HTML displayed to the user is returned. The QWeb template engine is usually used to render HTML.

### Add endpoint controller

By convention, controller code is placed in the /controllers subdirectory. To add a controller, first edit the **library_app/__init__.py** file and import the **controllers** subdirectory as follows:

```
from . import models
from . import controllers
```

Then add the **library_app/controllers/__init__.py** file to make the directory importable by Python, and add an **import** statement to import the **main.py** Python file that will implement the controller code later, as follows:

```
from . import main
```

Next, create the actual controller file **library_app/controllers/main.py** and add the following code:

```
from odoo import http
class Books(http.Controller):
    @http.route('/library/books', auth='user')
    def list(self, **kwargs):
        Book = http.request.env['library.book']
        books = Book.search([])
        return http.request.render(
            'library_app.book_list_template', {'books':books})
```

The first line imports the **odoo.http** module, which is the core component that provides web-related functions. Then we create a controller object class that inherits from **http.Controller**.

The names we choose for the class and its methods are irrelevant. The @http.route decorator is the important part, which declares the URL endpoint to which it is bound, in this case **/books**. The current page uses the default permission control, requiring the user to log in.

Inside the controller method, we can access the runtime environment using http.request.env. We use it to get a recordset of all valid books in the catalog.

The last step is to use **http.request.render()** to process the **library_app.index_template** Qweb template and generate the output HTML. You can pass values ​​to the template through a dictionary, and here you pass the **books** recordset.

At this time, if you restart the Odoo server to reload the Python code and access **/library/books**, you will get a server-side error log: **ValueError: External ID not found in the system: library_app.book_list_template**. This is because we have not defined the template yet. Let's define the template together.

### Add QWeb template

QWeb templates are stored together with other view types, and the corresponding database files are usually placed in the /views subdirectory. We create the **views/book_list_template.xml** file as follows:

```
<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <template id="book_list_template" name="Book List">
        <div id="wrap" class="container">
            <h1>Books</h1>
            <t t-foreach="books" t-as="book">
                <div class="row">
                    <span t-field="book.name" />,
                    <span t-field="book.date_published" />,
                    <span t-field="book.publisher_id" />
                </div>
            </t>
        </div>
    </template>
</odoo>
```

The ` <template> ` element is used to declare a QWeb template, which is actually a shortcut to the base model - ir.ui.view record - that stores the template. The template contains the HTML to be used and uses Qweb specific properties.

**t-foreach** is used to iterate over each item in the variable books, obtained by calling **http.request.render()** in the controller. The **t-field** attribute is used to render the content of the Odoo record field.

Like other XML data files, QWeb template data files need to be declared in the module declaration file so that they can be loaded and used. Therefore, you need to edit the `__manifest__.py` file and add the following content:

```
    "data": [
        "security/library_security.xml",
        "security/ir.model.access.csv",
        "views/book_view.xml",
        "views/library_menu.xml",
        "views/book_list_template.xml",
    ],
```

After adding the XML file declaration to the declaration file, perform a module upgrade and the web page should be available. Open the `http://<my-server>:8069/library/books` URL as a logged in user, and a simple list of available books should be displayed, as shown below:

[![Figure 3.7: Book list webpage](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20d373039ee84dde9c88ea51ee7cf0ee~tplv-k3u1fbpfcp-zoom-1.image)](https://i.cdnl.ink/homepage/wp-content/uploads/2022/05/2022050711430275.png)

Figure 3.7: Book list webpage

This is a quick overview of Odoo's web features. These features will be discussed in depth in Chapter 13: Creating Websites and Portal Front-end Features in Odoo 15 Development.

## Quick Reference

Most of the components discussed here are discussed in other chapters, but here is a quick reference list:

- [Chapter 2 Odoo 15 Development Environment Preparation](2.md): About command line installation and upgrade modules
- [Chapter 5 Odoo 15 Development: Importing, Exporting, and Module Data](5.md): About creating XML and CSV data files
- [Chapter 6 Odoo 15 Development Model - Structured Application Data](6.md): About the model layer, define models and fields
- [Chapter 7 Odoo 15 Development Recordset - Using Model Data](7.md): About scope filter syntax and recordset operations
- [Chapter 8 Business Logic of Odoo 15 Development - Business Process Support](8.md): Business logic of Python methods
- [Chapter 10 Odoo 15 Development Background View - Design User Interface](10.md): Views, including window actions, menu items, forms, lists, and searches
- [Chapter 13 Odoo 15 Development: Creating Websites and Portal Front-end Functions](13.md): About web controllers and QWeb syntax

What is not covered elsewhere is access permissions, so here we provide a quick reference to these components.

### Access Rights

The internal system models are listed below:

- **res.groups**: **groups** related fields: **name**, **implied_ids**, **users**
- **res.users**: **users** related fields: **name**, **groups_id**
- **ir.model.access**: access control related fields: **name**, **model_id**, **group_id**, **perm_read**, **perm_write**, **perm_create**, **perm_unlink**
- **ir.access.rule**: record rule related fields: **name**, **model_id**, **groups**, **domain_force**

The XML IDs of the most relevant permission groups are listed below:

- **base.group_user**: **internal user**—any background user
- **base.group_system**: **Settings**—Administrators belong to this group
- **base.group_no_one**: **technical feature**, usually used to hide features from users
- **base.group_public**: **Public**, used to make the site open to anonymous users

The default user XML IDs provided by Odoo are listed below:

- **base.user_root**: system superuser, also known as **OdooBot**
- **base.user_admin**: default user, default name is **Administrator**
- **base.default_user**: The template used by new users in the background. This is a template and cannot be used, but you can copy it to create a new user
- **base.default_public user**: Template for creating new portal users

## Summary

In this article, we created a new module from scratch and learned about the commonly used components in modules: models, access permissions, menus, three basic view types (form view, list view, and search view), and business logic in model methods. We also learned how to create web pages using web controllers and QWeb templates.

During the learning process, we became familiar with the module development process, including module upgrades and application service restarts to make the changes take effect in Odoo.

Don't forget that you need to upgrade when adding model fields. Modifying Python files containing declarations requires restarting the server. Modifying XML or CSV files requires upgrading; if in doubt, restart the server and upgrade the module at the same time.

We have learned the basic elements and steps to create an Odoo application, but in most cases, our modules will extend existing applications to add functionality, which we will learn in the next article.

## Further reading

All topics covered in this article will be introduced in depth in subsequent chapters.

Related resources in the official documentation can be used as supplementary reading:

- [Creating Modules Course](https://www.odoo.com/documentation/15.0/howtos/backend.html)
- A set of coding standards and module development guidelines in the [Odoo Guidelines](https://www.odoo.com/documentation/15.0/reference/guidelines.html)
- The Odoo Community Alliance (OCA) Guide is a great resource for Odoo development best practices

Learning Python is also very important for Odoo development. There are some good Python books in the Packt book catalog, such as [Learn Python Programming – Second Edition](https://www.packtpub.com/application-development/learn-python-programming-second-edition).

Note: This blog has added [Mastering Python Automation Scripts - Operation and Maintenance Personnel Handbook](https://alanhou.org/mastering-python-scripting-system-administrators/) which can be used for in-depth learning of Python scripts.